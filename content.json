{"meta":{"title":"我的博客","subtitle":"每天进步一点点","description":null,"author":"陈泳仰","url":"https://chenyongyang.github.io"},"pages":[],"posts":[{"title":"Vue.js响应式原理","slug":"Vue-js响应式原理","date":"2018-10-26T12:17:02.000Z","updated":"2018-10-26T13:07:48.326Z","comments":true,"path":"2018/10/26/Vue-js响应式原理/","link":"","permalink":"https://chenyongyang.github.io/2018/10/26/Vue-js响应式原理/","excerpt":"","text":"主要由三部分组成Observer Compiler Watcher Observer监听数据变化，使得当数据变化时，我们有能力去执行一些操作 Compiler解析模板，将数据结合模板渲染到页面上 Watcher将两者结合起来，当挂载组件或初始化计算属性时，都会去实例化Watcher，将target传递给Observer，执行数据的getter方法，getter方法中取到target并收集到Dep中，这样就完成了依赖收集；当数据发生变化时，会调用dep.notify方法，通知所有的监听者Watcher，Watcher再调用参数中的回调函数update，更新视图","categories":[],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://chenyongyang.github.io/tags/Vue-js/"}]},{"title":"cookies、localStorage、sessionStorage三者的区别","slug":"cookies、localStorage、sessionStorage三者的区别","date":"2018-10-25T13:20:04.000Z","updated":"2018-10-25T13:58:40.414Z","comments":true,"path":"2018/10/25/cookies、localStorage、sessionStorage三者的区别/","link":"","permalink":"https://chenyongyang.github.io/2018/10/25/cookies、localStorage、sessionStorage三者的区别/","excerpt":"","text":"共同点都是客户端存储方案 不同点： cookies在浏览器和服务器之间传输，附加于HTTP报文中；localStorage、sessionStorage只是活动于浏览器端，不需要和服务器通信 cookies有path字段，可以规范cookies的存储路径；localStorage、sessionStorage没有 存储大小方面，cookies只有4KB；，这是由于它是存在于HTTP报文中，数据量自然不能过大；localStorage、sessionStorage能够存储5MB以上 数据的生命周期方面，cookies如果是存在于内存中，则在关闭浏览器后便被释放，如果存在于硬盘中，有个过期时间或可手动清除；localStorage如果不手动清除，将会一直存在；sessionStorage在当前浏览器关闭之前有效 作用域方面，cookies、localStorage只要是同源窗口就能生效（即使是不同浏览器）sessionStorage在不同的浏览器是不同的（即使是同个网站） localStorage、sessionStorage API提供了可监听的事件，可以在数据变动是执行相应动作 应用场景方面：cookies现在一般用于用户登录信息存储；localStorage、sessionStorage一般用于购物车、存储较大的数据量；表单信息；网站访客统计等；localStorage可做一些数据持久化工作，减少数据库的访问量","categories":[],"tags":[{"name":"前端存储","slug":"前端存储","permalink":"https://chenyongyang.github.io/tags/前端存储/"}]},{"title":"一起来学cookies","slug":"一起来学cookies","date":"2018-10-25T12:40:39.000Z","updated":"2018-10-25T13:52:35.435Z","comments":true,"path":"2018/10/25/一起来学cookies/","link":"","permalink":"https://chenyongyang.github.io/2018/10/25/一起来学cookies/","excerpt":"","text":"是什么 cookies，也叫作小型文本文件，本质上是存储在客户端的数据，网站能够通过这些数据来辨别用户身份 按照数据存储在客户端不同的位置，可以将cookies分为内存cookies、硬盘cookies 内存cookies和浏览器挂钩，当关闭了浏览器，其占用的内存也就被释放，内存cookies自然就被清除；也被称为非持久cookies 硬盘cookies，顾名思义就是存储在硬盘中的数据，一般都有个过期时间，用户也可以手动清除；也被称为持久cookies 应用场景 购物车，当用户选中一个商品到购物车，服务器端返回浏览器页面的同时，也会将选中的商品的信息放入cookies一起发送过去，当用户再选中商品时，浏览器在发送请求上会带上之前的cookies，服务器接收到后，就能够将新的商品添加到上一次的商品后一起返回响应，这实际上解决了HTTP无状态所带来的客户操作状态无法保存的限制。 网站登录。第一次登录时如果勾选了自动登录，那么服务器端接收到用户的表单数据，进行一系列验证，返回响应时会携带一个加密的cookies，这段cookies将存储在用户硬盘中，当第二次登录时，浏览器就可以发送这段cookies给服务器，服务器验证通过就可以直接登录了。 不足 cookies在服务器端和客户端之间的传输，总是附加在HTTP报文中，增加了流量 在HTTP中，cookies是明文的，不安全；可以考虑HTTPS 存储大小只有4KB，不适合复杂数据存储","categories":[],"tags":[{"name":"前端存储","slug":"前端存储","permalink":"https://chenyongyang.github.io/tags/前端存储/"}]},{"title":"浏览器缓存","slug":"浏览器缓存","date":"2018-10-21T09:14:21.000Z","updated":"2018-10-24T08:59:15.368Z","comments":true,"path":"2018/10/21/浏览器缓存/","link":"","permalink":"https://chenyongyang.github.io/2018/10/21/浏览器缓存/","excerpt":"什么是浏览器缓存？ 浏览器将对于已经请求过的资源缓存起来，等到下一次请求同样资源时，浏览器直接将缓存副本返回响应，不必向浏览器发送请求 浏览器缓存的好处 缩短网络请求的距离，减少延迟，加快网页打开速度，性能优化 资源重复利用，减少带宽，降低服务器压力 如何实现浏览器缓存？","text":"什么是浏览器缓存？ 浏览器将对于已经请求过的资源缓存起来，等到下一次请求同样资源时，浏览器直接将缓存副本返回响应，不必向浏览器发送请求 浏览器缓存的好处 缩短网络请求的距离，减少延迟，加快网页打开速度，性能优化 资源重复利用，减少带宽，降低服务器压力 如何实现浏览器缓存？ 首先来了解与缓存有关的HTTP报文字段 通用首部字段 Pragma 定义在Meta标签，通常指为no-cache，禁用缓存 1&lt;meta http-equiv=\"Pragma\" content=\"no-cache\"&gt; 浏览器设置作用不大，服务器端设置为主 仅IE能识别 与禁用缓存相对的是启用缓存，Expires出现了 Cache-Control 解决服务器和浏览器时间标准不一致 定义缓存过期时间，与Pragma Expires相比，优先级最高 如果资源缓存过期，但资源还是一样，在资源较大的情况下，是不应该又去服务器请求一遍的 我们需要让服务器知道浏览器缓存的资源是否跟自己一致，如果一致就让浏览器直接用缓存，这时候Last-Modified出现了 请求首部字段 If-Match 浏览器通过PUT方法时，通过这个字段传递ETag If-None-Match 浏览器告诉服务器如果ETag没匹配上，返回新资源，否则返回304 ETag就存储在这个字段中 If-Modified-Since 浏览器通过这个字段告诉服务器如果最后修改时间一致，则返回304 Last-Modified就存储在这个字段中 If-Unmodified-Since 浏览器通过这个字段告诉服务器如果最后修改时间不一致，则返回412 响应首部字段 ETag 服务器返回资源的同时，将ETag一并返回，浏览器接收到后为资源打上这个标记，下一次请求时，将这个值发给服务器，服务器和之前的作对比，如果一致，返回304；否则返回新资源 通过对资源进行某个算法，生成一个类似md5的唯一标识符，而不仅仅靠修改时间 如果和Last-Modified同时使用，需要两者都返回304，才会走缓存，否则返回新资源 实体首部字段 Expires 服务器返回的资源缓存过期时间（GMT 格林尼治时间），时间点是服务器的时间 在浏览器，IE下可以这样设置，这种做法也仅限IE 1&lt;meta http-equiv=\"expires\" content=\"mon, 18 apr 2016 14:30:00 GMT\"&gt; 得在服务器端报头返回该字段，缓存过期时间才能正确生效 同时设置，Pragma优先级更高 但如果服务器和浏览器的时间标准不一致，这个设置也就失效了，因此Cache-Control出现了 Last-Modified 服务器端资源的最后修改时间 服务器向浏览器返回资源的同时，会携带一个Last-Modified，它的值为格林尼治时间；浏览器接收到响应后，会给资源标记上这个值，等到下一次向服务器请求时，将这个值一并发过去，服务器就会对比浏览器发过来的值和之前发给浏览器的值，如果两个最后修改的时间一致，则返回304，让浏览器直接读取缓存资源 不足：当服务器资源被修改，但实际内容没变，这个时候还是会将资源返回，这时候ETag出现了 强缓存不会发送请求到服务器，协商缓存会发送请求到服务器，通过请求首部字段验证 强缓存：Pragma / Expires / Cache-Control 协商缓存：Last-Modified/If-Modified-Since、ETag/If-None-Match 具体应用 使用Expires来兼容旧浏览器 使用Cache-Control来精准控制缓存 使用ETag和Last-Modified来进一步复用 一般缓存时间为60s 对于静态资源（如图片）则会久一点 浏览器可以在图片的URL后设置max-age 浏览器可以对静态资源以版本形式发布，加上hash值，以确保能及时从服务器获取最新资源","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/tags/计算机网络/"}]},{"title":"动手实现Vue.js响应式","slug":"动手实现Vue-js响应式","date":"2018-10-21T05:43:14.000Z","updated":"2018-10-24T08:47:49.256Z","comments":true,"path":"2018/10/21/动手实现Vue-js响应式/","link":"","permalink":"https://chenyongyang.github.io/2018/10/21/动手实现Vue-js响应式/","excerpt":"想要实现这样的功能：1234567let price = 5let quantity = 2let total = price * quantityconsole.log(total) // 10price = 10 // 修改dataconsole.log(total) // 如果是响应式，就应该是20 现在就是来实现这样的响应式功能 既然要实现改变单价或质量，总价格就会更新，本质上就是当数据改变时，再次执行计价 因此我们应该把这个计价封装成一个函数，以便之后调用123target = () =&gt; &#123; total = price * quantity&#125;","text":"想要实现这样的功能：1234567let price = 5let quantity = 2let total = price * quantityconsole.log(total) // 10price = 10 // 修改dataconsole.log(total) // 如果是响应式，就应该是20 现在就是来实现这样的响应式功能 既然要实现改变单价或质量，总价格就会更新，本质上就是当数据改变时，再次执行计价 因此我们应该把这个计价封装成一个函数，以便之后调用123target = () =&gt; &#123; total = price * quantity&#125; 可能有多个对数据的处理函数，因此我们定义一个数组来存储12storge = []storge.push(target) 以后我们想要调用计较函数，就可以这样1storge.forEach(run =&gt; run()) 完整代码如下1234567891011121314151617181920212223let price = 5let quantity = 2let total = 0let target = nulllet storge = [] // 存储targetfunction recode()&#123; // 将target记录起来 storge.push(target)&#125;function replay()&#123; storge.forEach(run =&gt; run())&#125;target = () =&gt; &#123; total = price * quantity&#125;recode()target()price = 10console.log(total) // 10replay()console.log(total) // 20 我们现在有了一个target，同时将target存储在storge列表中，通过replay方法通知target。这一切都可以封装成一个类，这是依赖类就出现了。12345678910111213141516171819202122232425262728class Dep&#123; constructor()&#123; this.subscribers = []; // 代替storge &#125; depend()&#123; // 代替recode if(target &amp;&amp; !this.subscribers.includes(target))&#123; this.subscribers.push(target) &#125; &#125; notify()&#123; // 代替replay this.subscribers.forEach(sub =&gt; sub()) // run target or observer &#125;&#125;let dep = new Dep()let price = 5let quantity = 2let total = 0let target = () =&gt; &#123; total = price * quantity&#125;dep.depend() // 添加依赖（这个依赖指的是target）target()console.log(total) // 10price = 10console.log(total) // 10dep.notify()console.log(total) // 20 现在还有一点不足：还需要去定义和调用target；我们完全可以把target的定义和调用都封装起来 我们要封装的就是创建监听更新的匿名函数的行为；这时候可以引进Watcher观察者函数123456function watcher(func)&#123; target = func; dep.depend(); target(); target = null&#125; 这样我们就把创建监听更新的匿名函数、依赖的收集都封装到一起。 将代码整合一下1234567891011121314151617181920212223242526272829303132class Dep&#123; constructor(func)&#123; this.subscribers = []; // 代替storge this.target = null; this.watcher(func); &#125; depend()&#123; // 代替recode if(this.target &amp;&amp; !this.subscribers.includes(this.target))&#123; this.subscribers.push(this.target) &#125; &#125; notify()&#123; // 代替replay this.subscribers.forEach(sub =&gt; sub()) // run target or observer &#125; watcher(func)&#123; this.target = func this.depend() this.target() this.target = null &#125;&#125;let price = 5;let quantity = 2let total = 0let dep = new Dep(()=&gt;&#123;total = price * quantity&#125;);price = 10 // data数据修改console.log(total) // 10dep.notify() // dep通知target更新console.log(total) // 20 到此为止，当我们修改数据一修改，只要通知存储在依赖类实例的target，即可实现依赖数据的修改 但我们还需要手动执行dep.notify，我们希望数据一修改就自动执行dep.notify，而且应该是每个数据都有这个能力 我们希望当访问数据对象属性时，将target所指向的更新函数添加到subscribers中；当修改数据对象属性时，通知其依赖数据 我们需要一些方式来挂钩数据属性，使得当访问它时，能够将target推送到subscribers数组中；当它被修改时，运行存储在subscribers数组中的函数 这时候就需要Object.defineProperty() 最终代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142let data = &#123; price: 5, quantity: 2&#125;let target = nullclass Dep&#123; constructor()&#123; this.subscribers = [] &#125; depend()&#123; if(target &amp;&amp; !this.subscribers.includes(target))&#123; this.subscribers.push(target) &#125; &#125; notify()&#123; this.subscribers.forEach(sub=&gt;sub()) &#125;&#125;Object.keys(data).forEach(key =&gt; &#123; let value = data[key] let dep = new Dep() Object.defineProperty(data, key, &#123; get()&#123; dep.depend() return value; &#125;, set(newValue)&#123; value = newValue dep.notify() &#125; &#125;)&#125;)function watcher(func)&#123; target = func target() target = null&#125;watcher(() =&gt; &#123; data.total = data.price * data.quantity&#125;) 至此，我们实现了price quantity的响应式，一旦数据更改，依赖的数据也随之更改","categories":[],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://chenyongyang.github.io/tags/Vue-js/"}]},{"title":"学习Vue.js源码的前置知识","slug":"学习Vue-js源码的前置知识","date":"2018-07-21T04:00:00.000Z","updated":"2018-10-24T08:59:25.589Z","comments":true,"path":"2018/07/21/学习Vue-js源码的前置知识/","link":"","permalink":"https://chenyongyang.github.io/2018/07/21/学习Vue-js源码的前置知识/","excerpt":"","text":"前置知识 Flow JavaScript静态类型检测，类似于typescript object.defineProperty proxy get set","categories":[],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://chenyongyang.github.io/tags/Vue-js/"}]},{"title":"Hexo基本操作","slug":"Hexo基本操作","date":"2017-10-30T00:00:00.000Z","updated":"2018-10-24T08:59:34.414Z","comments":true,"path":"2017/10/30/Hexo基本操作/","link":"","permalink":"https://chenyongyang.github.io/2017/10/30/Hexo基本操作/","excerpt":"","text":"写文章 hexo new 文章标题 预览效果 hexo s 开启hexo server 在localhost调试 发布到github page hexo clean 清除历史数据 hexo d -g 先生成再发布","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://chenyongyang.github.io/tags/Hexo/"}]}]}