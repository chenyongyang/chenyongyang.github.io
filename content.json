{"meta":{"title":"我的博客","subtitle":"每天进步一点点","description":null,"author":"陈泳仰","url":"https://chenyongyang.github.io"},"pages":[{"title":"分类","date":"2018-10-27T07:18:24.000Z","updated":"2018-10-27T07:18:55.864Z","comments":true,"path":"categories/index.html","permalink":"https://chenyongyang.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-10-27T07:23:35.000Z","updated":"2018-10-27T07:23:55.780Z","comments":true,"path":"tags/index.html","permalink":"https://chenyongyang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HTTP/2初探","slug":"HTTP-2初探","date":"2018-10-28T02:22:40.000Z","updated":"2018-10-28T02:47:42.946Z","comments":true,"path":"2018/10/28/HTTP-2初探/","link":"","permalink":"https://chenyongyang.github.io/2018/10/28/HTTP-2初探/","excerpt":"","text":"HTTP/2新特性1、单一长连接 客户端向服务器请求资源时，不管请求资源的多少，只会建立一条TCP连接。这样就能够减少TCP握手的次数，提高网络效率 HTTP性能优化的关键在于低延迟，主要就是因为建立TCP连接所消耗的时间太长（TCP慢启动），而单一长连接一定程度上缓解了这个问题 2、多路复用 允许同时通过单一HTTP/2连接发起多重的请求-响应消息 这主要是解决了HTTP/1.1限制了客户端在同一时间请求同一域名的次数，超过次数会被阻塞。多路复用使得在同一时间点上，可以存在多个资源的请求，这些不同的请求存放在每个二进制帧中，以此提高并发量 3、头部压缩，通过HPACK算法压缩头部，减少报文体积 4、服务器推送。在客户端还没向服务器请求某资源时，服务器主动推送某资源给客户端，客户端将这个资源缓存起来，以后要用到时就可以直接走缓存了","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/categories/计算机网络/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://chenyongyang.github.io/tags/HTTP/"}]},{"title":"变量提升和函数提升","slug":"变量提升和函数提升","date":"2018-10-27T13:47:47.000Z","updated":"2018-10-27T13:56:26.500Z","comments":true,"path":"2018/10/27/变量提升和函数提升/","link":"","permalink":"https://chenyongyang.github.io/2018/10/27/变量提升和函数提升/","excerpt":"","text":"写程序时，无论是变量还是函数，我们都是先声明后使用，其实也应该是这样来写。 但有时候我们将两者的顺序颠倒了，先使用了变量或先调用了函数，再来声明变量或函数，发现竟然也没报错。 其实这也是因为JavaScript在执行代码之前，已经将变量声明和函数声明都放到内存中了，到了执行阶段程序就可以从内存中读取变量和函数的定义了。 123num = 6;num + 7;var num; // num为13 12345func(\"hello\");function func(str) &#123; console.log(str); // 输出hello&#125; 需要注意的一点是：JavaScript只提升声明，不提升初始化。123var x = 1; console.log(x, y); // 这里y是undefined，因为下面的y不仅仅是声明，是声明并初始化var y = 2;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chenyongyang.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chenyongyang.github.io/tags/JavaScript/"}]},{"title":"Cookie与Session","slug":"Cookie与Session","date":"2018-10-27T12:29:08.000Z","updated":"2018-10-27T13:02:23.933Z","comments":true,"path":"2018/10/27/Cookie与Session/","link":"","permalink":"https://chenyongyang.github.io/2018/10/27/Cookie与Session/","excerpt":"","text":"Cookie和Session都被用于会话跟踪，它们都是为了解决HTTP无状态这一个特性，不同点在于Cookie是在客户端保存状态；而Session是在服务器端保存状态 如果Cookies不设置过期时间，则默认为会话Cookie，这种Cookie存储在内存中，随浏览器关闭而清除；如果设置了过期时间，则Cookies就存储在客户端硬盘中 Session保存在服务器端。通常浏览器第一次访问某页面，发送给服务器的请求中自然就没有携带SESSIONID，那么当服务器就会生成一个SESSIONID，并将其放在响应头中，以cookie的形式返回给客户端，客户端拿到这个ID保存起来，下一次访问时就可以将这个ID发送给服务器端，服务器就可以根据这个ID到保存session的地方寻找对应的数据，将数据返回给客户端 Cookie是实现Session的一种方式，这个SESSIONID就存储在cookie中 如果用户禁用了cookie，服务器端如何跟踪用户呢？利用URL重写，浏览器将SESSIONID作为get请求的参数发送给服务器端，这样服务器照样可以找到session的数据 区别 cookie保存在客户端，session保存在服务器端 session存储量比cookie大 用户可以看到cookie，但是看不到session session依赖SESSIONID，SESSIONID存储在cookie中，从这个角度看，cookie是session的一种实现形式","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://chenyongyang.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://chenyongyang.github.io/tags/HTTP/"}]},{"title":"作用域链与变量解析","slug":"作用域链与变量解析","date":"2018-10-27T11:01:10.000Z","updated":"2018-10-27T11:02:54.611Z","comments":true,"path":"2018/10/27/作用域链与变量解析/","link":"","permalink":"https://chenyongyang.github.io/2018/10/27/作用域链与变量解析/","excerpt":"","text":"概念作用域链是一个对象列表或者链表，这组对象定义了这段代码作用域内的变量 如何产生当代码在一个环境中执行，就会创建这个变量对象的作用域链 变量解析过程变量解析时，首先从作用域链的前端开始，作用域链的前端就是当前执行代码所在环境的变量对象，如果找不到就往后回溯，到上一级执行环境的变量对象中找，如果在链的末端还找不到，则抛出一个引用错误异常","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chenyongyang.github.io/categories/JavaScript/"}],"tags":[{"name":"作用域链","slug":"作用域链","permalink":"https://chenyongyang.github.io/tags/作用域链/"}]},{"title":"探究vue双向绑定原理","slug":"探究vue双向绑定原理","date":"2018-10-27T06:46:02.000Z","updated":"2018-10-27T07:27:13.993Z","comments":true,"path":"2018/10/27/探究vue双向绑定原理/","link":"","permalink":"https://chenyongyang.github.io/2018/10/27/探究vue双向绑定原理/","excerpt":"","text":"双向绑定就是数据和视图的双向绑定，数据变化更新视图，视图变化更新数据 视图变化更新数据，我们可以通过监听页面上的DOM事件，从而去修改数据 数据变化更新视图，首先进行数据劫持，使得我们能够感知到数据的变化；感知到数据的变化后，通知它的订阅者，订阅者执行更新函数，进而更新视图 订阅者是如何形成的呢？它是通过Compile解析器来实现的，解析器扫描每个节点，将相关指令初始化为一个订阅者Watcher，当然解析器在这个过程中还进行了其他操作，例如更换模板数据、绑定函数等 Observer观察者劫持data对象所有数据，监听数据变动；Compile解析器对每个节点进行解析，提取模板中的各种指令，获取数据对象，将数据更换到模板中，对视图进行初始化渲染，同时将更新视图的函数传递给订阅者；因为一个数据可能不止被用了一次，也就是它可能有多个订阅者，因此我们需要一个数据结构来存储订阅者，它就是Dep，Dep中存储着数据依赖项也就是订阅者，这个过程是在劫持数据对象时get方法中进行的；一旦数据有变动，就进入了set方法，观察者就通知Dep，Dep就通知所有的订阅者，订阅者接收到数据变动后，调用更新函数去更新视图，这就是数据变化更新视图的背后的原理。","categories":[{"name":"vue.js","slug":"vue-js","permalink":"https://chenyongyang.github.io/categories/vue-js/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://chenyongyang.github.io/tags/vue-js/"}]},{"title":"HTTP权威指南学习笔记——HTTPS","slug":"HTTP权威指南学习笔记——HTTPS","date":"2018-10-27T06:10:17.000Z","updated":"2018-10-27T13:12:57.651Z","comments":true,"path":"2018/10/27/HTTP权威指南学习笔记——HTTPS/","link":"","permalink":"https://chenyongyang.github.io/2018/10/27/HTTP权威指南学习笔记——HTTPS/","excerpt":"","text":"HTTPS概述HTTPS的主要原理是，它在将HTTP报文发送给TCP之前，先发给一个安全层，对报文进行加密处理。现在HTTP的安全层是通过SSL和TLS来实现的，一般都统称为SSL。 HTTPS方案一般通过URL来告知Web服务器执行HTTP安全协议版本，也就是URL方案的前缀为http或https 如果URL走的是HTTPS，客户端会开启443默认端口来连接服务器，进行握手过程，同服务器交换SSL安全参数，附上加密的HTTP命令 安全传输建立流程客户端发送一个HTTPS方案的请求之后，客户端会通过443端口与服务器建立连接，TCP连接建立以后，客户端和服务器会初始化SSL层，沟通加密参数，并交换密钥，握手完成后，SSL初始化完成，客户端发送请求报文给安全层。 如何保障安全对称加密、非对称加密、数字证书 加密的HTTPS事务流程 建立到服务器443端口的TCP连接 双方进行SSL安全参数握手 在SSL发送HTTP请求，在TCP发送已经加密的请求 在SSL发送HTTP响应，在TCP发送已经加密的响应 SSL关闭通知 TCP关闭连接 SSL安全参数握手流程 客户端向服务器发送可供选择的密码，并请求证书 服务器发送选中密码和证书 客户端发送保密信息，双方生成密钥 双方互相告知，开始加密过程 站点证书的有效性校验 日期检测 签名颁发者可信度检测 签名检测 站点身份检测","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/tags/计算机网络/"}]},{"title":"前端性能优化01","slug":"前端性能优化01","date":"2018-10-27T05:48:03.000Z","updated":"2018-10-27T07:27:03.495Z","comments":true,"path":"2018/10/27/前端性能优化01/","link":"","permalink":"https://chenyongyang.github.io/2018/10/27/前端性能优化01/","excerpt":"","text":"前端性能优化可以从很多方面入手，其中网络请求层面是一个重点内容，而这方面一般有两个思路，1、减少网络请求；2、减小网络请求的体积 减少网络请求体积的一般做法有：合并请求资源，制作雪碧图，压缩请求等 js执行层面之所以耗费资源主要是源于内存泄漏，所以我们经常说要及时清空没有被使用的引用 页面渲染层面，一般强调减少DOM操作，这也是虚拟DOM产生的背景","categories":[{"name":"性能优化","slug":"性能优化","permalink":"https://chenyongyang.github.io/categories/性能优化/"}],"tags":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://chenyongyang.github.io/tags/前端性能优化/"}]},{"title":"GET和POST的区别","slug":"GET和POST的区别","date":"2018-10-27T02:31:47.000Z","updated":"2018-10-27T07:26:17.978Z","comments":true,"path":"2018/10/27/GET和POST的区别/","link":"","permalink":"https://chenyongyang.github.io/2018/10/27/GET和POST的区别/","excerpt":"","text":"要讲清楚这两个请求方法的区别，其实可以从RTC（一个互联网规范）对HTTP协议描述的特性出发 HTTP协议对请求方法规定了这几个特性：安全性、幂等性、可缓存性 首先是安全性。如果一个方法的语义是只读，那它就是安全的，也就是意味着它不会对服务器的资源作任何的改动；它是无害的。这些都是属于规范层面，但在实际操纵中的实现不一定是安全的，例如用GET方法修改用户信息 其次是幂等性。概念是同个方法执行多次和执行一次效果是一样的。GET方法是幂等的，POST方法不幂等。原因是可以从为什么要引入幂等性思考？主要是为了处理同一个请求重复发送的问题。例如用户填写了表单，表单数据用POST提交到服务器，此时用户不小心使得浏览器后退或者刷新了页面，浏览器就会提示用户数据会丢失，保证POST过去的都不是重复的 最后是可缓存性。GET方法可以缓存，POST方法不可缓存，这也是处于语义上的需要 还要其他一些区别：GET有长度限制，这和GET是通过URL参数传递信息有关；POST长度不限； 总结：GET方法是获取指定资源，它是安全的、幂等的、可以缓存的；POST方法根据报文主体的payload对指定资源作处理，它是不安全、不幂等 参考链接：MDN上关于HTTP的阐述","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/categories/计算机网络/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://chenyongyang.github.io/tags/HTTP/"}]},{"title":"Vue.js响应式原理","slug":"Vue-js响应式原理","date":"2018-10-26T12:17:02.000Z","updated":"2018-10-27T07:26:02.611Z","comments":true,"path":"2018/10/26/Vue-js响应式原理/","link":"","permalink":"https://chenyongyang.github.io/2018/10/26/Vue-js响应式原理/","excerpt":"","text":"主要由三部分组成Observer Compiler Watcher Observer监听数据变化，使得当数据变化时，我们有能力去执行一些操作 Compiler解析模板，将数据结合模板渲染到页面上 Watcher将两者结合起来，当挂载组件或初始化计算属性时，都会去实例化Watcher，将target传递给Observer，执行数据的getter方法，getter方法中取到target并收集到Dep中，这样就完成了依赖收集；当数据发生变化时，会调用dep.notify方法，通知所有的监听者Watcher，Watcher再调用参数中的回调函数update，更新视图","categories":[{"name":"vue.js","slug":"vue-js","permalink":"https://chenyongyang.github.io/categories/vue-js/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://chenyongyang.github.io/tags/vue-js/"}]},{"title":"Cookie、localStorage、sessionStorage三者的区别","slug":"Cookie、localStorage、sessionStorage三者的区别","date":"2018-10-25T13:20:04.000Z","updated":"2018-10-27T12:27:52.816Z","comments":true,"path":"2018/10/25/Cookie、localStorage、sessionStorage三者的区别/","link":"","permalink":"https://chenyongyang.github.io/2018/10/25/Cookie、localStorage、sessionStorage三者的区别/","excerpt":"","text":"共同点都是客户端存储方案 不同点： Cookie在浏览器和服务器之间传输，附加于HTTP报文中；localStorage、sessionStorage只是活动于浏览器端，不需要和服务器通信 Cookie有path字段，可以规范Cookie的存储路径；localStorage、sessionStorage没有 存储大小方面，Cookie只有4KB；，这是由于它是存在于HTTP报文中，数据量自然不能过大；localStorage、sessionStorage能够存储5MB以上 数据的生命周期方面，Cookie如果是存在于内存中，则在关闭浏览器后便被释放，如果存在于硬盘中，有个过期时间或可手动清除；localStorage如果不手动清除，将会一直存在；sessionStorage在当前浏览器关闭之前有效 作用域方面，Cookie、localStorage只要是同源窗口就能生效（即使是不同浏览器）sessionStorage在不同的浏览器是不同的（即使是同个网站） localStorage、sessionStorage API提供了可监听的事件，可以在数据变动是执行相应动作 应用场景方面：Cookie现在一般用于用户登录信息存储；localStorage、sessionStorage一般用于购物车、存储较大的数据量；表单信息；网站访客统计等；localStorage可做一些数据持久化工作，减少数据库的访问量","categories":[{"name":"前端存储","slug":"前端存储","permalink":"https://chenyongyang.github.io/categories/前端存储/"}],"tags":[{"name":"前端存储","slug":"前端存储","permalink":"https://chenyongyang.github.io/tags/前端存储/"}]},{"title":"一起来学Cookie","slug":"一起来学Cookie","date":"2018-10-25T12:40:39.000Z","updated":"2018-10-27T12:28:11.247Z","comments":true,"path":"2018/10/25/一起来学Cookie/","link":"","permalink":"https://chenyongyang.github.io/2018/10/25/一起来学Cookie/","excerpt":"","text":"是什么 Cookie，也叫作小型文本文件，本质上是存储在客户端的数据，网站能够通过这些数据来辨别用户身份 按照数据存储在客户端不同的位置，可以将Cookie分为内存Cookie、硬盘Cookie 内存Cookie和浏览器挂钩，当关闭了浏览器，其占用的内存也就被释放，内存Cookie自然就被清除；也被称为非持久Cookie 硬盘Cookie，顾名思义就是存储在硬盘中的数据，一般都有个过期时间，用户也可以手动清除；也被称为持久Cookie 应用场景 购物车，当用户选中一个商品到购物车，服务器端返回浏览器页面的同时，也会将选中的商品的信息放入Cookie一起发送过去，当用户再选中商品时，浏览器在发送请求上会带上之前的Cookie，服务器接收到后，就能够将新的商品添加到上一次的商品后一起返回响应，这实际上解决了HTTP无状态所带来的客户操作状态无法保存的限制。 网站登录。第一次登录时如果勾选了自动登录，那么服务器端接收到用户的表单数据，进行一系列验证，返回响应时会携带一个加密的Cookie，这段Cookie将存储在用户硬盘中，当第二次登录时，浏览器就可以发送这段Cookie给服务器，服务器验证通过就可以直接登录了。 不足 Cookie在服务器端和客户端之间的传输，总是附加在HTTP报文中，增加了流量 在HTTP中，Cookie是明文的，不安全；可以考虑HTTPS 存储大小只有4KB，不适合复杂数据存储","categories":[{"name":"前端存储","slug":"前端存储","permalink":"https://chenyongyang.github.io/categories/前端存储/"}],"tags":[{"name":"前端存储","slug":"前端存储","permalink":"https://chenyongyang.github.io/tags/前端存储/"}]},{"title":"前端缓存","slug":"前端缓存","date":"2018-10-21T09:14:21.000Z","updated":"2018-10-27T07:29:16.651Z","comments":true,"path":"2018/10/21/前端缓存/","link":"","permalink":"https://chenyongyang.github.io/2018/10/21/前端缓存/","excerpt":"什么是前端缓存？ 浏览器将对于已经请求过的资源缓存起来，等到下一次请求同样资源时，浏览器直接将缓存副本返回响应，不必向浏览器发送请求 前端缓存的好处 缩短网络请求的距离，减少延迟，加快网页打开速度，性能优化 资源重复利用，减少带宽，降低服务器压力 如何实现前端缓存？","text":"什么是前端缓存？ 浏览器将对于已经请求过的资源缓存起来，等到下一次请求同样资源时，浏览器直接将缓存副本返回响应，不必向浏览器发送请求 前端缓存的好处 缩短网络请求的距离，减少延迟，加快网页打开速度，性能优化 资源重复利用，减少带宽，降低服务器压力 如何实现前端缓存？ 首先来了解与缓存有关的HTTP报文字段 通用首部字段 Pragma 定义在Meta标签，通常指为no-cache，禁用缓存 1&lt;meta http-equiv=\"Pragma\" content=\"no-cache\"&gt; 浏览器设置作用不大，服务器端设置为主 仅IE能识别 与禁用缓存相对的是启用缓存，Expires出现了 Cache-Control 解决服务器和浏览器时间标准不一致 定义缓存过期时间，与Pragma Expires相比，优先级最高 如果资源缓存过期，但资源还是一样，在资源较大的情况下，是不应该又去服务器请求一遍的 我们需要让服务器知道前端缓存的资源是否跟自己一致，如果一致就让浏览器直接用缓存，这时候Last-Modified出现了 请求首部字段 If-Match 浏览器通过PUT方法时，通过这个字段传递ETag If-None-Match 浏览器告诉服务器如果ETag没匹配上，返回新资源，否则返回304 ETag就存储在这个字段中 If-Modified-Since 浏览器通过这个字段告诉服务器如果最后修改时间一致，则返回304 Last-Modified就存储在这个字段中 If-Unmodified-Since 浏览器通过这个字段告诉服务器如果最后修改时间不一致，则返回412 响应首部字段 ETag 服务器返回资源的同时，将ETag一并返回，浏览器接收到后为资源打上这个标记，下一次请求时，将这个值发给服务器，服务器和之前的作对比，如果一致，返回304；否则返回新资源 通过对资源进行某个算法，生成一个类似md5的唯一标识符，而不仅仅靠修改时间 如果和Last-Modified同时使用，需要两者都返回304，才会走缓存，否则返回新资源 实体首部字段 Expires 服务器返回的资源缓存过期时间（GMT 格林尼治时间），时间点是服务器的时间 在浏览器，IE下可以这样设置，这种做法也仅限IE 1&lt;meta http-equiv=\"expires\" content=\"mon, 18 apr 2016 14:30:00 GMT\"&gt; 得在服务器端报头返回该字段，缓存过期时间才能正确生效 同时设置，Pragma优先级更高 但如果服务器和浏览器的时间标准不一致，这个设置也就失效了，因此Cache-Control出现了 Last-Modified 服务器端资源的最后修改时间 服务器向浏览器返回资源的同时，会携带一个Last-Modified，它的值为格林尼治时间；浏览器接收到响应后，会给资源标记上这个值，等到下一次向服务器请求时，将这个值一并发过去，服务器就会对比浏览器发过来的值和之前发给浏览器的值，如果两个最后修改的时间一致，则返回304，让浏览器直接读取缓存资源 不足：当服务器资源被修改，但实际内容没变，这个时候还是会将资源返回，这时候ETag出现了 强缓存不会发送请求到服务器，协商缓存会发送请求到服务器，通过请求首部字段验证 强缓存：Pragma / Expires / Cache-Control 协商缓存：Last-Modified/If-Modified-Since、ETag/If-None-Match If-Modified-Since/Last-ModifiedIf-Modified-Since存在于请求头中，当它被发送到服务器时，服务器会将它和Last-Modified的值作对比，如果两者日期一致，则告知浏览器可以使用本地缓存 If-None-Match/EtagIf-None-Match存储一个字符串，当它被发送到服务器时，服务器会将它和Etag的值作对比，如果匹配上了，则告知浏览器可以使用本地缓存 流程是这样的：浏览器第一次请求页面，服务器在返回结果的同时，也将Last-Modified和Etag值传递过去；浏览器接收到响应，将这两个值都缓存起来；等到下一次请求同个页面，这两个值会将这两个值分别放入If-Modified-Since/If-None-Match并发送到服务器，服务器拿这两个值和之前的作对比，如果其中一个命中，就返回304和空响应体，这就是协商缓存的过程 具体应用 使用Expires来兼容旧浏览器 使用Cache-Control来精准控制缓存 使用ETag和Last-Modified来进一步复用 一般缓存时间为60s 对于静态资源（如图片）则会久一点 浏览器可以在图片的URL后设置max-age 浏览器可以对静态资源以版本形式发布，加上hash值，以确保能及时从服务器获取最新资源","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/tags/计算机网络/"}]},{"title":"动手实现Vue.js响应式","slug":"动手实现Vue-js响应式","date":"2018-10-21T05:43:14.000Z","updated":"2018-10-27T07:27:36.155Z","comments":true,"path":"2018/10/21/动手实现Vue-js响应式/","link":"","permalink":"https://chenyongyang.github.io/2018/10/21/动手实现Vue-js响应式/","excerpt":"想要实现这样的功能：1234567let price = 5let quantity = 2let total = price * quantityconsole.log(total) // 10price = 10 // 修改dataconsole.log(total) // 如果是响应式，就应该是20 现在就是来实现这样的响应式功能 既然要实现改变单价或质量，总价格就会更新，本质上就是当数据改变时，再次执行计价 因此我们应该把这个计价封装成一个函数，以便之后调用123target = () =&gt; &#123; total = price * quantity&#125;","text":"想要实现这样的功能：1234567let price = 5let quantity = 2let total = price * quantityconsole.log(total) // 10price = 10 // 修改dataconsole.log(total) // 如果是响应式，就应该是20 现在就是来实现这样的响应式功能 既然要实现改变单价或质量，总价格就会更新，本质上就是当数据改变时，再次执行计价 因此我们应该把这个计价封装成一个函数，以便之后调用123target = () =&gt; &#123; total = price * quantity&#125; 可能有多个对数据的处理函数，因此我们定义一个数组来存储12storge = []storge.push(target) 以后我们想要调用计较函数，就可以这样1storge.forEach(run =&gt; run()) 完整代码如下1234567891011121314151617181920212223let price = 5let quantity = 2let total = 0let target = nulllet storge = [] // 存储targetfunction recode()&#123; // 将target记录起来 storge.push(target)&#125;function replay()&#123; storge.forEach(run =&gt; run())&#125;target = () =&gt; &#123; total = price * quantity&#125;recode()target()price = 10console.log(total) // 10replay()console.log(total) // 20 我们现在有了一个target，同时将target存储在storge列表中，通过replay方法通知target。这一切都可以封装成一个类，这是依赖类就出现了。12345678910111213141516171819202122232425262728class Dep&#123; constructor()&#123; this.subscribers = []; // 代替storge &#125; depend()&#123; // 代替recode if(target &amp;&amp; !this.subscribers.includes(target))&#123; this.subscribers.push(target) &#125; &#125; notify()&#123; // 代替replay this.subscribers.forEach(sub =&gt; sub()) // run target or observer &#125;&#125;let dep = new Dep()let price = 5let quantity = 2let total = 0let target = () =&gt; &#123; total = price * quantity&#125;dep.depend() // 添加依赖（这个依赖指的是target）target()console.log(total) // 10price = 10console.log(total) // 10dep.notify()console.log(total) // 20 现在还有一点不足：还需要去定义和调用target；我们完全可以把target的定义和调用都封装起来 我们要封装的就是创建监听更新的匿名函数的行为；这时候可以引进Watcher观察者函数123456function watcher(func)&#123; target = func; dep.depend(); target(); target = null&#125; 这样我们就把创建监听更新的匿名函数、依赖的收集都封装到一起。 将代码整合一下1234567891011121314151617181920212223242526272829303132class Dep&#123; constructor(func)&#123; this.subscribers = []; // 代替storge this.target = null; this.watcher(func); &#125; depend()&#123; // 代替recode if(this.target &amp;&amp; !this.subscribers.includes(this.target))&#123; this.subscribers.push(this.target) &#125; &#125; notify()&#123; // 代替replay this.subscribers.forEach(sub =&gt; sub()) // run target or observer &#125; watcher(func)&#123; this.target = func this.depend() this.target() this.target = null &#125;&#125;let price = 5;let quantity = 2let total = 0let dep = new Dep(()=&gt;&#123;total = price * quantity&#125;);price = 10 // data数据修改console.log(total) // 10dep.notify() // dep通知target更新console.log(total) // 20 到此为止，当我们修改数据一修改，只要通知存储在依赖类实例的target，即可实现依赖数据的修改 但我们还需要手动执行dep.notify，我们希望数据一修改就自动执行dep.notify，而且应该是每个数据都有这个能力 我们希望当访问数据对象属性时，将target所指向的更新函数添加到subscribers中；当修改数据对象属性时，通知其依赖数据 我们需要一些方式来挂钩数据属性，使得当访问它时，能够将target推送到subscribers数组中；当它被修改时，运行存储在subscribers数组中的函数 这时候就需要Object.defineProperty() 最终代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142let data = &#123; price: 5, quantity: 2&#125;let target = nullclass Dep&#123; constructor()&#123; this.subscribers = [] &#125; depend()&#123; if(target &amp;&amp; !this.subscribers.includes(target))&#123; this.subscribers.push(target) &#125; &#125; notify()&#123; this.subscribers.forEach(sub=&gt;sub()) &#125;&#125;Object.keys(data).forEach(key =&gt; &#123; let value = data[key] let dep = new Dep() Object.defineProperty(data, key, &#123; get()&#123; dep.depend() return value; &#125;, set(newValue)&#123; value = newValue dep.notify() &#125; &#125;)&#125;)function watcher(func)&#123; target = func target() target = null&#125;watcher(() =&gt; &#123; data.total = data.price * data.quantity&#125;) 至此，我们实现了price quantity的响应式，一旦数据更改，依赖的数据也随之更改","categories":[{"name":"vue.js","slug":"vue-js","permalink":"https://chenyongyang.github.io/categories/vue-js/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://chenyongyang.github.io/tags/vue-js/"}]},{"title":"学习Vue.js源码的前置知识","slug":"学习Vue-js源码的前置知识","date":"2018-07-21T04:00:00.000Z","updated":"2018-10-27T07:27:44.437Z","comments":true,"path":"2018/07/21/学习Vue-js源码的前置知识/","link":"","permalink":"https://chenyongyang.github.io/2018/07/21/学习Vue-js源码的前置知识/","excerpt":"","text":"前置知识 Flow JavaScript静态类型检测，类似于typescript object.defineProperty proxy get set","categories":[{"name":"vue.js","slug":"vue-js","permalink":"https://chenyongyang.github.io/categories/vue-js/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://chenyongyang.github.io/tags/vue-js/"}]},{"title":"Hexo基本操作","slug":"Hexo基本操作","date":"2017-10-30T00:00:00.000Z","updated":"2018-10-27T07:27:26.934Z","comments":true,"path":"2017/10/30/Hexo基本操作/","link":"","permalink":"https://chenyongyang.github.io/2017/10/30/Hexo基本操作/","excerpt":"","text":"写文章 hexo new 文章标题 预览效果 hexo s 开启hexo server 在localhost调试 发布到github page hexo clean 清除历史数据 hexo d -g 先生成再发布","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://chenyongyang.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://chenyongyang.github.io/tags/Hexo/"}]}]}