{"meta":{"title":"我的博客","subtitle":"每天进步一点点","description":"陈泳仰的个人博客","author":"陈泳仰","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"浏览器缓存","slug":"浏览器缓存","date":"2018-10-21T09:14:21.000Z","updated":"2018-10-24T08:59:15.368Z","comments":true,"path":"2018/10/21/浏览器缓存/","link":"","permalink":"http://yoursite.com/2018/10/21/浏览器缓存/","excerpt":"什么是浏览器缓存？ 浏览器将对于已经请求过的资源缓存起来，等到下一次请求同样资源时，浏览器直接将缓存副本返回响应，不必向浏览器发送请求 浏览器缓存的好处 缩短网络请求的距离，减少延迟，加快网页打开速度，性能优化 资源重复利用，减少带宽，降低服务器压力 如何实现浏览器缓存？","text":"什么是浏览器缓存？ 浏览器将对于已经请求过的资源缓存起来，等到下一次请求同样资源时，浏览器直接将缓存副本返回响应，不必向浏览器发送请求 浏览器缓存的好处 缩短网络请求的距离，减少延迟，加快网页打开速度，性能优化 资源重复利用，减少带宽，降低服务器压力 如何实现浏览器缓存？ 首先来了解与缓存有关的HTTP报文字段 通用首部字段 Pragma 定义在Meta标签，通常指为no-cache，禁用缓存 1&lt;meta http-equiv=\"Pragma\" content=\"no-cache\"&gt; 浏览器设置作用不大，服务器端设置为主 仅IE能识别 与禁用缓存相对的是启用缓存，Expires出现了 Cache-Control 解决服务器和浏览器时间标准不一致 定义缓存过期时间，与Pragma Expires相比，优先级最高 如果资源缓存过期，但资源还是一样，在资源较大的情况下，是不应该又去服务器请求一遍的 我们需要让服务器知道浏览器缓存的资源是否跟自己一致，如果一致就让浏览器直接用缓存，这时候Last-Modified出现了 请求首部字段 If-Match 浏览器通过PUT方法时，通过这个字段传递ETag If-None-Match 浏览器告诉服务器如果ETag没匹配上，返回新资源，否则返回304 ETag就存储在这个字段中 If-Modified-Since 浏览器通过这个字段告诉服务器如果最后修改时间一致，则返回304 Last-Modified就存储在这个字段中 If-Unmodified-Since 浏览器通过这个字段告诉服务器如果最后修改时间不一致，则返回412 响应首部字段 ETag 服务器返回资源的同时，将ETag一并返回，浏览器接收到后为资源打上这个标记，下一次请求时，将这个值发给服务器，服务器和之前的作对比，如果一致，返回304；否则返回新资源 通过对资源进行某个算法，生成一个类似md5的唯一标识符，而不仅仅靠修改时间 如果和Last-Modified同时使用，需要两者都返回304，才会走缓存，否则返回新资源 实体首部字段 Expires 服务器返回的资源缓存过期时间（GMT 格林尼治时间），时间点是服务器的时间 在浏览器，IE下可以这样设置，这种做法也仅限IE 1&lt;meta http-equiv=\"expires\" content=\"mon, 18 apr 2016 14:30:00 GMT\"&gt; 得在服务器端报头返回该字段，缓存过期时间才能正确生效 同时设置，Pragma优先级更高 但如果服务器和浏览器的时间标准不一致，这个设置也就失效了，因此Cache-Control出现了 Last-Modified 服务器端资源的最后修改时间 服务器向浏览器返回资源的同时，会携带一个Last-Modified，它的值为格林尼治时间；浏览器接收到响应后，会给资源标记上这个值，等到下一次向服务器请求时，将这个值一并发过去，服务器就会对比浏览器发过来的值和之前发给浏览器的值，如果两个最后修改的时间一致，则返回304，让浏览器直接读取缓存资源 不足：当服务器资源被修改，但实际内容没变，这个时候还是会将资源返回，这时候ETag出现了 强缓存不会发送请求到服务器，协商缓存会发送请求到服务器，通过请求首部字段验证 强缓存：Pragma / Expires / Cache-Control 协商缓存：Last-Modified/If-Modified-Since、ETag/If-None-Match 具体应用 使用Expires来兼容旧浏览器 使用Cache-Control来精准控制缓存 使用ETag和Last-Modified来进一步复用 一般缓存时间为60s 对于静态资源（如图片）则会久一点 浏览器可以在图片的URL后设置max-age 浏览器可以对静态资源以版本形式发布，加上hash值，以确保能及时从服务器获取最新资源","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"动手实现Vue.js响应式","slug":"动手实现Vue-js响应式","date":"2018-10-21T05:43:14.000Z","updated":"2018-10-24T08:47:49.256Z","comments":true,"path":"2018/10/21/动手实现Vue-js响应式/","link":"","permalink":"http://yoursite.com/2018/10/21/动手实现Vue-js响应式/","excerpt":"想要实现这样的功能：1234567let price = 5let quantity = 2let total = price * quantityconsole.log(total) // 10price = 10 // 修改dataconsole.log(total) // 如果是响应式，就应该是20 现在就是来实现这样的响应式功能 既然要实现改变单价或质量，总价格就会更新，本质上就是当数据改变时，再次执行计价 因此我们应该把这个计价封装成一个函数，以便之后调用123target = () =&gt; &#123; total = price * quantity&#125;","text":"想要实现这样的功能：1234567let price = 5let quantity = 2let total = price * quantityconsole.log(total) // 10price = 10 // 修改dataconsole.log(total) // 如果是响应式，就应该是20 现在就是来实现这样的响应式功能 既然要实现改变单价或质量，总价格就会更新，本质上就是当数据改变时，再次执行计价 因此我们应该把这个计价封装成一个函数，以便之后调用123target = () =&gt; &#123; total = price * quantity&#125; 可能有多个对数据的处理函数，因此我们定义一个数组来存储12storge = []storge.push(target) 以后我们想要调用计较函数，就可以这样1storge.forEach(run =&gt; run()) 完整代码如下1234567891011121314151617181920212223let price = 5let quantity = 2let total = 0let target = nulllet storge = [] // 存储targetfunction recode()&#123; // 将target记录起来 storge.push(target)&#125;function replay()&#123; storge.forEach(run =&gt; run())&#125;target = () =&gt; &#123; total = price * quantity&#125;recode()target()price = 10console.log(total) // 10replay()console.log(total) // 20 我们现在有了一个target，同时将target存储在storge列表中，通过replay方法通知target。这一切都可以封装成一个类，这是依赖类就出现了。12345678910111213141516171819202122232425262728class Dep&#123; constructor()&#123; this.subscribers = []; // 代替storge &#125; depend()&#123; // 代替recode if(target &amp;&amp; !this.subscribers.includes(target))&#123; this.subscribers.push(target) &#125; &#125; notify()&#123; // 代替replay this.subscribers.forEach(sub =&gt; sub()) // run target or observer &#125;&#125;let dep = new Dep()let price = 5let quantity = 2let total = 0let target = () =&gt; &#123; total = price * quantity&#125;dep.depend() // 添加依赖（这个依赖指的是target）target()console.log(total) // 10price = 10console.log(total) // 10dep.notify()console.log(total) // 20 现在还有一点不足：还需要去定义和调用target；我们完全可以把target的定义和调用都封装起来 我们要封装的就是创建监听更新的匿名函数的行为；这时候可以引进Watcher观察者函数123456function watcher(func)&#123; target = func; dep.depend(); target(); target = null&#125; 这样我们就把创建监听更新的匿名函数、依赖的收集都封装到一起。 将代码整合一下1234567891011121314151617181920212223242526272829303132class Dep&#123; constructor(func)&#123; this.subscribers = []; // 代替storge this.target = null; this.watcher(func); &#125; depend()&#123; // 代替recode if(this.target &amp;&amp; !this.subscribers.includes(this.target))&#123; this.subscribers.push(this.target) &#125; &#125; notify()&#123; // 代替replay this.subscribers.forEach(sub =&gt; sub()) // run target or observer &#125; watcher(func)&#123; this.target = func this.depend() this.target() this.target = null &#125;&#125;let price = 5;let quantity = 2let total = 0let dep = new Dep(()=&gt;&#123;total = price * quantity&#125;);price = 10 // data数据修改console.log(total) // 10dep.notify() // dep通知target更新console.log(total) // 20 到此为止，当我们修改数据一修改，只要通知存储在依赖类实例的target，即可实现依赖数据的修改 但我们还需要手动执行dep.notify，我们希望数据一修改就自动执行dep.notify，而且应该是每个数据都有这个能力 我们希望当访问数据对象属性时，将target所指向的更新函数添加到subscribers中；当修改数据对象属性时，通知其依赖数据 我们需要一些方式来挂钩数据属性，使得当访问它时，能够将target推送到subscribers数组中；当它被修改时，运行存储在subscribers数组中的函数 这时候就需要Object.defineProperty() 最终代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142let data = &#123; price: 5, quantity: 2&#125;let target = nullclass Dep&#123; constructor()&#123; this.subscribers = [] &#125; depend()&#123; if(target &amp;&amp; !this.subscribers.includes(target))&#123; this.subscribers.push(target) &#125; &#125; notify()&#123; this.subscribers.forEach(sub=&gt;sub()) &#125;&#125;Object.keys(data).forEach(key =&gt; &#123; let value = data[key] let dep = new Dep() Object.defineProperty(data, key, &#123; get()&#123; dep.depend() return value; &#125;, set(newValue)&#123; value = newValue dep.notify() &#125; &#125;)&#125;)function watcher(func)&#123; target = func target() target = null&#125;watcher(() =&gt; &#123; data.total = data.price * data.quantity&#125;) 至此，我们实现了price quantity的响应式，一旦数据更改，依赖的数据也随之更改","categories":[],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/tags/Vue-js/"}]},{"title":"学习Vue.js源码的前置知识","slug":"学习Vue-js源码的前置知识","date":"2018-07-21T04:00:00.000Z","updated":"2018-10-24T08:59:25.589Z","comments":true,"path":"2018/07/21/学习Vue-js源码的前置知识/","link":"","permalink":"http://yoursite.com/2018/07/21/学习Vue-js源码的前置知识/","excerpt":"","text":"前置知识 Flow JavaScript静态类型检测，类似于typescript object.defineProperty proxy get set","categories":[],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/tags/Vue-js/"}]},{"title":"Hexo基本操作","slug":"Hexo基本操作","date":"2017-10-30T00:00:00.000Z","updated":"2018-10-24T08:59:34.414Z","comments":true,"path":"2017/10/30/Hexo基本操作/","link":"","permalink":"http://yoursite.com/2017/10/30/Hexo基本操作/","excerpt":"","text":"写文章 hexo new 文章标题 预览效果 hexo s 开启hexo server 在localhost调试 发布到github page hexo clean 清除历史数据 hexo d -g 先生成再发布","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]}]}