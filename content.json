{"meta":{"title":"我的博客","subtitle":"每天进步一点点","description":null,"author":"陈泳仰","url":"https://chenyongyang.github.io"},"pages":[{"title":"分类","date":"2018-10-27T07:18:24.000Z","updated":"2018-10-27T07:18:55.864Z","comments":true,"path":"categories/index.html","permalink":"https://chenyongyang.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-10-27T07:23:35.000Z","updated":"2018-10-27T07:23:55.780Z","comments":true,"path":"tags/index.html","permalink":"https://chenyongyang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"面试汇总","slug":"面试汇总","date":"2019-03-24T12:40:36.000Z","updated":"2019-03-26T14:01:09.787Z","comments":true,"path":"2019/03/24/面试汇总/","link":"","permalink":"https://chenyongyang.github.io/2019/03/24/面试汇总/","excerpt":"","text":"水平居中 垂直居中 水平垂直居中 apply接收的是数组，call接收参数列表 js继承方式 借用构造函数 组合继承 原型继承，后来别Object.create()规范化了 寄生式，没必要为了继承超类的原型对象而调用超类构造函数，只需将超类原型指向给一个空构造函数，然后返回该构造函数的实例对象 寄生组合式，和寄生式类似，区别在于对象属性方面仍然是通过借用构造函数来继承 箭头函数 this指向问题 不可以当做构造函数，无法使用new 不存在arguments对象，可用rest代替 Promise 有异步操作时，就要用到promise来封装 reject方法等同于抛出错误 已经resolve了，就不能抛出错误了 then方法中的第二个参数定义的是reject状态的回调函数，但是一般不这么做，一般是将promise所产生的错误统一由catch方法来捕获，因为promise的错误具有冒泡性质，用catch可以捕获then方法执行中的错误，类似于try…catch… finally方法意味着无论如何，最后都会执行它，比如关掉服务器 将多个promise实例，包装成一个新的promise实例 resolve方法将现有对象转为promise对象 reject类似于throw，是用来抛出错误的；catch是用来处理错误 如果在 then 的第一个函数里抛出了异常，后面的 catch 能捕获到，而第二个函数捕获不到 link和@import的区别 link不仅可以引入css，还支持rss等其他事务；@import只支持css link在页面加载时同步引入css，@import需要等到页面加载完毕后才引入 事件绑定 行内绑定 动态绑定 事件监听 jq事件绑定 bind,one,unbind navigator.userAgent获取浏览器版本 serviceworker的用途 消息推送 离线缓存 json jsonp json是一种数据格式； jsonp是一种数据调用格式，带callback的json就是jsonp 利用script标签没有跨域限制的“漏洞”来达到与第三方通讯的目的。当需要通讯时，本站脚本创建一个script元素，地址指向第三方的API网址，并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如：callback({“name”:”hax”,”gender”:”Male”}) 这样浏览器会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。主要是利用了html标签的src属性没有同源限制，也就是支持跨域 domready onroad 首先要清楚dom文档加载的步骤为：1.解析html结构；2.加载外部脚本和样式表文件；3解析并执行脚本；4.dom树构建完成；5.加载图片等外部文件；6.页面加载完毕。domready（也叫DOMContentLoaded ），在第4步完成后触发；图片onload是在第5步完成后触发；页面onload是第6步完成后触发。由此可见三者执行顺序为：domready→图片load→页面load。 domready和onload事件区别，前者：在DOM文档结构准备完毕后就可以对DOM进行操作；后者：整个document文档（包括图片等加载信息)加载完成后才能对DOM进行操作。关键区别就在于后者需要等待图片等资源加载完毕后才执行 js事件（捕获 冒泡） dom2级事件 事件流：从页面接收事件的顺序，主要分为事件冒泡流和事件捕获流 事件冒泡：事件从嵌套层次最深的最具体的元素接收，然后逐级向上传播到不具体的节点；事件捕获则反之 三个阶段：捕获阶段、目标阶段、冒泡阶段 事件处理程序：dom0级、dom2级：addEventListener、removeEventListener 123btn.addEventListener(\"click\", function()&#123;alert(this.id);&#125;, false); true代表在捕获时调用，false代表在冒泡时调用，这样可以添加多个事件处理程序 一般都是将事件处理程序添加到冒泡阶段，兼容性更好 事件委托（事件代理） 在一个标签嵌套的DOM结构中，对每一级的元素都绑定事件。最内层的元素先触发，再往外一层一层触发，出于冒泡机制。如何点击元素时父元素事件不触发，也就是如何阻止冒泡？event.stopPropagation()起到阻止捕获和冒泡阶段中事件进一步传输；IE中是用e.cancelBubble = true 作用域链是在定义时还是执行时创建的？ 执行环境中所有的变量和函数都保存在变量对象中，由解析器在后台使用 每个函数都有自己的执行环境 当代码在一个环境中执行时，会创建变量对象的一个作用域链，这说明函数定义时没有作用域链存在，只有调用时有 作用域链最前端是当前执行代码的变量对象，如果环境是函数，则变量对象是活动对象 作用：标识符解析 原生ajax post请求 XMLHttpRequest对象 open方法，接收三个参数：get或post、请求Url、是否异步发送 send方法 1234567xhr.open(\"get\", \"example.txt\", false);xhr.send(null);if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText);&#125; else &#123; alert(\"Request was unsuccessful: \" + xhr.status);&#125; 发送异步请求，需要检测XHR对象的readyState属性，这个属性一变化，就会触发readystatechange事件 123456789101112var xhr = createXHR();xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; // 4代表已经接收到全部响应数据 if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert(\"Request was unsuccessful: \" + xhr.status); &#125; &#125;&#125;;xhr.open(\"get\", \"example.txt\", true);xhr.send(null); 异步script加载方式 脚本加载会导致DOM构建停止，出现白屏，所以一般都是把脚本放在body标签底部位置进行加载 除了底部加载脚本这个方法，还有其他方法解决阻塞问题？ defer属性 渲染文档的时候，异步下载资源，但不会立即执行，会等到所有元素解析完再执行 兼容性问题，只被Internet Explorer 4+和Firefox 3.5+支持，不是理想方案 async属性 在渲染文档是异步下载资源 defer和async的区别 defer按顺序执行，async乱序 defer下载完后不会立即执行；而async下载完后会立即执行，因此执行过程中也会阻塞元素渲染 动态脚本加载，是非阻塞Javascript下载中最常用的模式，因为它可以跨浏览器，而且简单易用 1234var script = document.createElement (\"script\");script.type = \"text/javascript\";script.src = \"file1.js\"; document.body.appendChild(script); 用XHR对象下载代码，并注入到页面 基本类型值 引用类型值 undefined null boolean string number object symbol这七种数据类型 基本数据类型是按值访问的，存放在栈内存中 引用类型值是按引用访问的，存放在堆内存中 typeof能够返回 undefined null boolean string number object function 判断数组的几种方式 instanceof 原型链方式 数组.proto.constructor===Array Object.prototype.toString.call(数组) Array.isArray() 内存泄漏 如果闭包的作用域链中保存着一个HTML 元素，那么就意味着该元素将无法被销毁 需要解除对DOM对象的引用 xss跨站脚本 反射型（非持久型） 对于 xss 反射型攻击，主要是诱使用户点击恶意的链接或者访问存在漏洞的内容，可以有如下方式： 攻击者可以将恶意链接直接发送给受信任用户，发送的方式有很多种，比如 email, 网站的私信、评论等 攻击者可以购买存在漏洞网站的广告，将恶意链接插入在广告的链接中 存储型（持久型）——&gt;&gt;&gt;输入检查 将一段恶意代码写在评论中，等待其他用户浏览评论时，就自动执行了js代码（获取cookie，并传输给攻击者的服务器）； 基于DOM ——&gt;&gt;&gt;输出检查 通过恶意脚本修改DOM结构 如何防范？ HttpOnly 防止劫取 Cookie 输入检查，对用户输入进行检查、过滤和转义 输出检查，在变量输出到html页面时，将其进行编码或转义 csrf跨站请求伪造 劫持受信任用户向服务器发送非预期请求 攻击者借助受害者的cookie骗取服务器的信任 涉及到浏览器的cookie策略 cookie有两种：会话期cookie和持久性cookie，后者可以指定过期时间 攻击者放了一个链接，这个链接指向一些删除操作，主要目的是改变服务器的数据 如何防范？ 验证码 referer check 在http请求头中的referer字段，表示该请求的来源地址 对每一个删帖请求，验证其referer值，如果该值指向其他网站，那就有可能是跨站伪请求 1234if (req.headers.referer !== '正确的站点地址') &#123; res.write('csrf 攻击'); return;&#125; 检查referer，还能防止图片盗链 当referer为空时, 返回正确的图；当referer不为空, 且host命中我的目标网站时, 返回正确的图；当referer不为空, 但host未能命中我的目标网站时, 返回错误的图 添加token验证 基本思路是在请求中添加一些攻击者无法伪造的信息，这些信息也不能存储在cookie中。在请求中添加一个类似随机数的token，服务器建立拦截器来验证 正则去掉字符串首尾空格 str.replace(/(^\\s)|(\\s$)/g, ‘’) 输入URL发生了什么 当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个 DNS 查询（浏览器缓存-&gt;系统缓存-&gt;路由器缓存）。这能使浏览器获得请求对应的 IP 地址。 浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。 一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。 此时，Web 服务器提供资源服务，客户端开始下载资源。 浏览器解析HTML生成DOM树，在根据CSS生成渲染树；浏览器缓存相应的信息，查看是否需要更新缓存；呈现页面。 缓存4个字段及优先级 Expires Cache-control：max-age=6000(毫秒)/no-cache/no-store/private/public last-modified Etag 缓存优先级 强缓存&gt;弱缓存 cache-control&gt;expires ETag &gt; Last-Modified ctrl f5 所发送的请求头包含no cache，才会跳过缓存；f5发送请求头中会触发协商缓存 性能优化：重排重绘、事件委托、异步无阻塞加载js、懒加载、虚拟列表、缓存、代码分割、雪碧图、减少HTTP请求 编码优化 提高数据读取速度，缓存对象成员值 DOM 缓存DOM属性和元素 重排、重绘时，先让元素脱离文档流，操作完毕后再插入文档流，减少重排重绘次数 事件委托 流程控制 避免使用for in 减少迭代 静态资源优化 压缩静态文本，开启gzip 图片优化 响应式图片 视频替换gif图 交付优化 异步无阻塞加载JS script放底部 deferer async 动态创建script标签 ajax请求js代码注入页面 懒加载 优先加载关键css 资源提示 dns-prefetch preconnect prefetch prerender preload 快速响应的用户界面 骨架屏 loading动画 构建优化 预编译 代码分割 服务端渲染 import函数导入模块 善用缓存 开启gzip，通常用来压缩静态文件。首先浏览器在请求头中设置accept-coding: gzip，这表明浏览器支持gzip。当服务器接收到请求后，判断浏览器是否支持gzip，如果支持就返回压缩后的内容，如果不支持则发送未压缩内容，一般都是在响应头添加content-encoding: gzip css性能优化 不要使用嵌套过多、过于复杂的选择器 将首屏渲染所需要的关键css内联到html中 对于次重要的css可以采用异步加载 压缩css文件 减少使用@import引入css，因为它不能实现并行下载；其次它会打乱资源的下载顺序 css3动画和js动画的区别 css 浏览器对前者会进行一定的优化 自然降级 js 兼容性好 效果丰富 移动端兼容 点击事件有300ms延迟，可以用fastclick解决，或者使用zepto的touch模块 非可点击元素监听click事件，需要设置cursor: pointer h5底部输入框被键盘遮挡 如何解决css动画页面闪白、卡顿 可能地使用合成属性transform和opacity来设计CSS3动画 移动端布局 响应式布局，媒体查询 rem，根据font-size来布局 设置viewport中的width vm + rem 对于vm的兼容性，可以使用viewport-units-polyfill解决 1像素问题 物理像素和逻辑像素，之间存在一个比例关系，可以通过window.devicePixelRatio获取，所以设计稿上的1px，在实际上会比较粗 解决方案 媒体查询，根据-webkit-min-device-pixel-ratio的不同，来设置小数像素 用js来获取这个比例，再设置小数像素 border-image background-image 盒模型 IE盒模型 width = border + padding + content W3C标准盒模型 width = content 可以通过box-sizing来设置不同的盒模型，该属性默认是content-box，可以改为border-box 怪异模式和标准模式 盒模型不同 尽量用border-box，这样可以直接设置子元素的width，不受padding的影响 new这个过程发生了什么 创建了一个空对象 将构造函数的this指向这个空对象 为新对象添加属性 返回新对象 vue双向绑定原理：数据劫持、发布-订阅模式 具体实现：数据劫持是通过Object.defineProperty() 视图到数据这一块可以通过事件监听来实现 比较关键的就是数据到视图这一块，定义一个observer观察者，用来劫持并监听所有数据的变化，如果有变化，就通知订阅者；定义一个watcher订阅者，接收来自观察者的信息，当数据发生变化时，执行函数，更新视图；定义一个compile，用来扫描解析节点和指令、初始化模板数据、初始化订阅者 任何没有设置doctype的Html都将以混杂模式来解析 浅拷贝 object.assgin 展开运算符 深拷贝 JSON.parse(JSON.stringify(obj)) 递归逐一赋值 new运算符的执行过程 创建一个空对象 将构造函数的this指向空对象 为空对象添加属性 返回该对象 es6推出的新数据结构set和map set集合中的元素是唯一的、不重复 map和对象类似，区别在于map的键可以是任意数据类型 两者都提供了一些方法，让我们处理数据 函数柯里化 为函数预置参数，以便重复利用 数组乱序123arr.sort(function ()&#123; return Math.random() - 0.5&#125;) 数组扁平化123arr.flat = function ()&#123; return this.toString().split(',').map(item =&gt; +item)&#125; 数组去重123456789function only(arr)&#123; var newarr = [] for(var i = 0; i &lt; arr.length; i++)&#123; if(newarr.indexOf(arr[i]) == -1)&#123; newarr.push(arr[i]) &#125; &#125; return newarr &#125; 浏览器跨标签通信 获取句柄，父页面通过window.open()这个接口打开子页面，然后设置当子页面加载onload的时候，将传递的信息作为postMessage的参数；这时子页面上就可以调用window.onmessage接口，获取到父页面传递过来的信息 123456789//A.htmlconst child = window.open('child.html', 'child')child.onload = () =&gt; &#123; child.postMessage('message', location.origin)&#125;//B.htmlwindow.onmessage = event =&gt; &#123; event.data&#125; localstorage、cookie 内存泄漏 意外的全局变量，使得这个变量挂在window对象上，没办法被清除，解决方法是：使用严格模式、将其设置为null 忘记关停定时器，导致定时器内的dom节点一直被引用，没办法回收 没有移除事件监听器 闭包 本以为已经移除了一些没用的dom节点，没想到移除的dom节点还被其他节点所引用，导致无法彻底移除 css3动画 transition：执行变化的属性 变化持续的时间 变化的样式 并不是所有的属性都支持 需要事件触发，没办法自动发生1transition: all 2s ease-in-out animation 可以设置任意多的关键帧，所以动画比较丰富12345@keyframes 动画名 &#123;0% &#123; top: 0; left: 0px&#125;50% &#123; top: 30px; left: 20px; &#125;100% &#123; top: 0; left: 30px;&#125;&#125; transform 顾名思义就是变形的意思，这里涉及的变形包括rotate旋转、skew扭曲、scale缩放、translate移动、matrix矩阵变形 常用的有：translate(x,y)进行2d转换、scale(x,y)进行2d缩放、rotate(角度数)进行2d旋转 类数组转数组 Array.prototype.slice.call(类数组)，因为数组slice方法如果不带任何参数，就是默认将数组从头到尾都浅拷贝一份 Array.from() 对于有遍历器接口的类数组，可以直接使用扩展运算符 关于this this指向：指向最后一个调用它的对象 如何改变this指向 new 箭头函数 call/apply/bind _this = this 函数调用有4种方式：直接调用、作为对象的方法、构造函数、call/apply dns解析过程 浏览器缓存 操作系统缓存 本地Host文件 路由器缓存 运营商DNS服务 根域名服务器 顶级域名服务器 主域名服务器 保存结果至缓存 TCP三次握手主要目的是要数据的发送和接收同步，通俗地讲就是 A：要连接你 B：好的收到，是现在连接吗 A：现在连接吧 TCP四次挥手 A：我要走了 B：好的收到，要等一下，我这边还有几句话没说完 B：我说完了，可以走了 A：那拜拜了 TCP和UDP的区别 有连接和无连接 保证数据的正确性和可能发生丢包 保证数据顺序，后者不保证 ==运算符会首先将操作对象转化为相同类型，具体表现为 只要其中有一个是NaN，就返回false 如果两个都是null或者undefined，返回true 如果两个都是基本数据类型，且类型不同，则将两者都将转化数值类型再比较 如果是引用类型值，则将其转化为基本类型再比较 bfc三个特性 防止外边距折叠(margin塌陷) 包含浮动元素 防止内容被浮动元素覆盖 如何获取url信息 URL很多信息都存储在window.location这个属性中，打印即可 经常会用到如何获取URL的参数及参数值，具体如下：123456789101112function GetRequest() &#123; var url = window.location.search; //获取url中\"?\"符后的字串 var theRequest = new Object() if (url.indexOf(\"?\") != -1) &#123; var str = url.substr(1) strs = str.split(\"&amp;\") for(var i = 0; i &lt; strs.length; i ++) &#123; theRequest[strs[i].split(\"=\")[0]]=unescape(strs[i].split(\"=\")[1]) &#125; &#125; return theRequest&#125; es5和es6关于类的区别 前者的toString方法是可枚举的，后者不可枚举 position属性有以下几个值 static，始终处于文档流给予的位置 inherit，继承父元素的position属性，有兼容性问题 fixed，相对于浏览器窗口固定位置；当如父元素设置了transform时，则根据父元素来定位 relative，根据在文档流的初始位置进行定位 absolute，根据距离最近的已定位的父元素进行定位 https 在整个加密过程中，要加密的内容有两个，一个是数据，另一个是用来加密数据的密钥。数据的加密，由于对称加密速度快、占用资源少，非对称加密对数据长度有限制，所以选择对称加密。那么也就会产生一个密钥，这个密钥需要双方都知道，如何传输这个密钥呢？也就是用非对称加密来传输密钥 数字证书就是用来安全传输公钥的 采用非对称加密来传输密钥，使用对称加密来加密数据 TCP是如何保证可靠传输的 确认和重传 数据校验 数据合理分片和排序 流量控制：当接收方来不及处理接收方的数据时，会提示发送方降低发送速率，防止包丢失 拥塞控制：当网络拥塞时，减少数据的发送","categories":[],"tags":[]},{"title":"面试学习5","slug":"面试学习5","date":"2019-03-20T06:31:41.000Z","updated":"2019-03-24T12:40:03.461Z","comments":true,"path":"2019/03/20/面试学习5/","link":"","permalink":"https://chenyongyang.github.io/2019/03/20/面试学习5/","excerpt":"","text":"css3动画transition transition: 执行变化的属性 变化持续的时间 变化的样式 并不是所有的属性都支持 需要事件触发，没办法自动发生1transition: all 2s ease-in-out animation 可以设置任意多的关键帧，所以动画比较丰富12345@keyframes 动画名 &#123; 0% &#123; top: 0; left: 0px&#125; 50% &#123; top: 30px; left: 20px; &#125; 100% &#123; top: 0; left: 30px;&#125;&#125; transform 顾名思义就是变形的意思，这里涉及的变形包括rotate旋转、skew扭曲、scale缩放、translate移动、matrix矩阵变形 常用的有：translate(x,y)进行2d转换、scale(x,y)进行2d缩放、rotate(角度数)进行2d旋转 类数组转数组 Array.prototype.slice.call(类数组)，因为数组slice方法如果不带任何参数，就是默认将数组从头到尾都浅拷贝一份 Array.from() 对于有遍历器接口的类数组，可以直接使用扩展运算符 关于this this指向：指向最后一个调用它的对象 如何改变this指向 new 箭头函数 call/apply/bind _this = this 函数调用有4种方式：直接调用、作为对象的方法、构造函数、call/apply dns解析过程 浏览器缓存 操作系统缓存 本地Host文件 路由器缓存 运营商DNS服务 根域名服务器 顶级域名服务器 主域名服务器 保存结果至缓存 TCP三次握手主要目的是要数据的发送和接收同步，通俗地讲就是 A：要连接你 B：好的收到，是现在连接吗 A：现在连接吧 TCP四次挥手 A：我要走了 B：好的收到，要等一下，我这边还有几句话没说完 B：我说完了，可以走了 A：那拜拜了 TCP和UDP的区别 有连接和无连接 保证数据的正确性和可能发生丢包 保证数据顺序，后者不保证 ==运算符会首先将操作对象转化为相同类型，具体表现为 只要其中有一个是NaN，就返回false 如果两个都是null或者undefined，返回true 如果两个都是基本数据类型，且类型不同，则将两者都将转化数值类型再比较 如果是引用类型值，则将其转化为基本类型再比较 bfc三个特性 防止外边距折叠(margin塌陷) 包含浮动元素 防止内容被浮动元素覆盖 如何获取url信息 URL很多信息都存储在window.location这个属性中，打印即可 经常会用到如何获取URL的参数及参数值，具体如下：123456789101112function GetRequest() &#123; var url = window.location.search; //获取url中\"?\"符后的字串 var theRequest = new Object() if (url.indexOf(\"?\") != -1) &#123; var str = url.substr(1) strs = str.split(\"&amp;\") for(var i = 0; i &lt; strs.length; i ++) &#123; theRequest[strs[i].split(\"=\")[0]]=unescape(strs[i].split(\"=\")[1]) &#125; &#125; return theRequest&#125; es5和es6关于类的区别 前者的toString方法是可枚举的，后者不可枚举","categories":[],"tags":[]},{"title":"面试学习4","slug":"面试学习4","date":"2019-03-19T07:05:16.000Z","updated":"2019-03-19T08:39:52.485Z","comments":true,"path":"2019/03/19/面试学习4/","link":"","permalink":"https://chenyongyang.github.io/2019/03/19/面试学习4/","excerpt":"","text":"浏览器跨标签通信 获取句柄，父页面通过window.open()这个接口打开子页面，然后设置当子页面加载onload的时候，将传递的信息作为postMessage的参数；这时子页面上就可以调用window.onmessage接口，获取到父页面传递过来的信息 123456789//A.htmlconst child = window.open('child.html', 'child')child.onload = () =&gt; &#123; child.postMessage('message', location.origin)&#125;//B.htmlwindow.onmessage = event =&gt; &#123; event.data&#125; localstorage、cookie 内存泄漏 意外的全局变量，使得这个变量挂在window对象上，没办法被清除，解决方法是：使用严格模式、将其设置为null 忘记关停定时器，导致定时器内的dom节点一直被引用，没办法回收 没有移除事件监听器 闭包 本以为已经移除了一些没用的dom节点，没想到移除的dom节点还被其他节点所引用，导致无法彻底移除","categories":[],"tags":[]},{"title":"面试学习3","slug":"面试学习3","date":"2019-03-16T08:05:17.000Z","updated":"2019-03-17T13:36:27.501Z","comments":true,"path":"2019/03/16/面试学习3/","link":"","permalink":"https://chenyongyang.github.io/2019/03/16/面试学习3/","excerpt":"","text":"盒模型 IE盒模型 width = border + padding + content W3C标准盒模型 width = content 可以通过box-sizing来设置不同的盒模型，该属性默认是content-box，可以改为border-box 怪异模式和标准模式 盒模型不同 尽量用border-box，这样可以直接设置子元素的width，不受padding的影响 new这个过程发生了什么 创建了一个空对象 将构造函数的this指向这个空对象 为新对象添加属性 返回新对象 vue双向绑定原理：数据劫持、发布-订阅模式 具体实现：数据劫持是通过Object.defineProperty() 视图到数据这一块可以通过事件监听来实现 比较关键的就是数据到视图这一块 定义一个observer观察者，用来劫持并监听所有数据的变化，如果有变化，就通知订阅者 定义一个watcher订阅者，接收来自观察者的信息，当数据发生变化时，执行函数，更新视图 定义一个compile，用来扫描解析节点和指令、初始化模板数据、初始化订阅者 任何没有设置doctype的Html都将以混杂模式来解析 浅拷贝 object.assgin 展开运算符 深拷贝 JSON.parse(JSON.stringify(obj)) 递归逐一赋值 new运算符的执行过程 创建一个空对象 将构造函数的this指向空对象 为空对象添加属性 返回该对象 es6推出的新数据结构set和map set集合中的元素是唯一的、不重复 map和对象类似，区别在于map的键可以是任意数据类型 两者都提供了一些方法，让我们处理数据 函数柯里化 为函数预置参数，以便重复利用 数组乱序123arr.sort(function ()&#123; return Math.random() - 0.5&#125;) 数组扁平化123arr.flat = function ()&#123; return this.toString().split(',').map(item =&gt; +item)&#125; 数组去重123456789function only(arr)&#123; var newarr = [] for(var i = 0; i &lt; arr.length; i++)&#123; if(newarr.indexOf(arr[i]) == -1)&#123; newarr.push(arr[i]) &#125; &#125; return newarr &#125;","categories":[],"tags":[]},{"title":"面试学习2","slug":"面试学习2","date":"2019-03-12T13:03:44.000Z","updated":"2019-03-16T13:27:19.306Z","comments":true,"path":"2019/03/12/面试学习2/","link":"","permalink":"https://chenyongyang.github.io/2019/03/12/面试学习2/","excerpt":"","text":"正则去掉字符串首尾空格 str.replace(/(^\\s)|(\\s$)/g, ‘’) 输入URL发生了什么 当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个 DNS 查询（浏览器缓存-&gt;系统缓存-&gt;路由器缓存）。这能使浏览器获得请求对应的 IP 地址。 浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。 一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。 此时，Web 服务器提供资源服务，客户端开始下载资源。 浏览器解析HTML生成DOM树，在根据CSS生成渲染树；浏览器缓存相应的信息，查看是否需要更新缓存；呈现页面。 缓存4个字段及优先级 Expires Cache-control：max-age=6000(毫秒)/no-cache/no-store/private/public last-modified Etag 强缓存&gt;弱缓存cache-control&gt;expiresETag &gt; Last-Modified ctrl f5 所发送的请求头包含no cache，才会跳过缓存；f5发送请求头中会触发协商缓存 性能优化：重排重绘、事件委托、异步无阻塞加载js、懒加载、虚拟列表、缓存、代码分割、雪碧图、减少HTTP请求 编码优化 提高数据读取速度，缓存对象成员值 DOM 缓存DOM属性和元素 重排、重绘时，先让元素脱离文档流，操作完毕后再插入文档流，减少重排重绘次数 事件委托 流程控制 避免使用for in 减少迭代 静态资源优化 压缩静态文本？ 图片优化 响应式图片 视频替换gif图 交付优化 异步无阻塞加载JS script放底部 deferer async 动态创建script标签 ajax请求js代码注入页面 懒加载 优先加载关键css 资源提示 dns-prefetch preconnect prefetch prerender preload 快速响应的用户界面 骨架屏 loading动画 构建优化 预编译 代码分割 服务端渲染 import函数导入模块 善用缓存 css3动画和js动画的区别 css 浏览器对前者会进行一定的优化 自然降级 js 兼容性好 效果丰富 移动端兼容点击事件有300ms延迟，可以用fastclick解决，或者使用zepto的touch模块 非可点击元素监听click事件，需要设置cursor: pointer h5底部输入框被键盘遮挡 css动画页面闪白、卡顿，解决：可能地使用合成属性transform和opacity来设计CSS3动画 移动端布局 响应式布局，媒体查询 rem，根据font-size来布局 设置viewport中的width vm + rem 对于vm的兼容性，可以使用viewport-units-polyfill解决 1像素问题 物理像素和逻辑像素，之间存在一个比例关系，可以通过window.devicePixelRatio获取，所以设计稿上的1px，在实际上会比较粗 解决方案 媒体查询，根据-webkit-min-device-pixel-ratio的不同，来设置小数像素 用js来获取这个比例，再设置小数像素 border-image background-image","categories":[],"tags":[]},{"title":"腾讯一面总结","slug":"腾讯一面总结","date":"2019-03-12T03:09:07.000Z","updated":"2019-03-17T12:23:16.473Z","comments":true,"path":"2019/03/12/腾讯一面总结/","link":"","permalink":"https://chenyongyang.github.io/2019/03/12/腾讯一面总结/","excerpt":"","text":"json jsonp json是一种数据格式； jsonp是一种数据调用格式，带callback的json就是jsonp 利用script标签没有跨域限制的“漏洞”来达到与第三方通讯的目的。当需要通讯时，本站脚本创建一个script元素，地址指向第三方的API网址，并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递）。第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如：callback({“name”:”hax”,”gender”:”Male”}) 这样浏览器会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。主要是利用了html标签的src属性没有同源限制，也就是支持跨域 domready onroad 首先要清楚dom文档加载的步骤为：1.解析html结构；2.加载外部脚本和样式表文件；3解析并执行脚本；4.dom树构建完成；5.加载图片等外部文件；6.页面加载完毕。domready（也叫DOMContentLoaded ），在第4步完成后触发；图片onload是在第5步完成后触发；页面onload是第6步完成后触发。由此可见三者执行顺序为：domready→图片load→页面load。 domready和onload事件区别，前者：在DOM文档结构准备完毕后就可以对DOM进行操作；后者：整个document文档（包括图片等加载信息)加载完成后才能对DOM进行操作。关键区别就在于后者需要等待图片等资源加载完毕后才执行 js事件（捕获 冒泡） dom2级事件 事件流：从页面接收事件的顺序，主要分为事件冒泡流和事件捕获流 事件冒泡：事件从嵌套层次最深的最具体的元素接收，然后逐级向上传播到不具体的节点；事件捕获则反之 三个阶段：捕获阶段、目标阶段、冒泡阶段 事件处理程序：dom0级、dom2级：addEventListener、removeEventListener 123btn.addEventListener(\"click\", function()&#123;alert(this.id);&#125;, false); true代表在捕获时调用，false代表在冒泡时调用，这样可以添加多个事件处理程序 一般都是将事件处理程序添加到冒泡阶段，兼容性更好 事件委托（事件代理） 作用域链是在定义时还是执行时创建的？ 执行环境中所有的变量和函数都保存在变量对象中，由解析器在后台使用 每个函数都有自己的执行环境 当代码在一个环境中执行时，会创建变量对象的一个作用域链，这说明函数定义时没有作用域链存在，只有调用时有 作用域链最前端是当前执行代码的变量对象，如果环境是函数，则变量对象是活动对象 作用：标识符解析 原生ajax post请求 XMLHttpRequest对象 open方法，接收三个参数：get或post、请求Url、是否异步发送 send方法 1234567xhr.open(\"get\", \"example.txt\", false);xhr.send(null);if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText);&#125; else &#123; alert(\"Request was unsuccessful: \" + xhr.status);&#125; 发送异步请求，需要检测XHR对象的readyState属性，这个属性一变化，就会触发readystatechange事件 123456789101112var xhr = createXHR();xhr.onreadystatechange = function()&#123; if (xhr.readyState == 4)&#123; // 4代表已经接收到全部响应数据 if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; alert(xhr.responseText); &#125; else &#123; alert(\"Request was unsuccessful: \" + xhr.status); &#125; &#125;&#125;;xhr.open(\"get\", \"example.txt\", true);xhr.send(null); 异步script加载方式 脚本加载会导致DOM构建停止，出现白屏，所以一般都是把脚本放在body标签底部位置进行加载 除了底部加载脚本这个方法，还有其他方法解决阻塞问题？ defer属性 渲染文档的时候，异步下载资源，但不会立即执行，会等到所有元素解析完再执行 兼容性问题，只被Internet Explorer 4+和Firefox 3.5+支持，不是理想方案 async属性 在渲染文档是异步下载资源 defer和async的区别 defer按顺序执行，async乱序 defer下载完后不会立即执行；而async下载完后会立即执行，因此执行过程中也会阻塞元素渲染 动态脚本加载，是非阻塞Javascript下载中最常用的模式，因为它可以跨浏览器，而且简单易用 1234var script = document.createElement (\"script\");script.type = \"text/javascript\";script.src = \"file1.js\"; document.body.appendChild(script); 用XHR对象下载代码，并注入到页面 基本类型值 引用类型值 undefined null boolean string number object symbol这七种数据类型 基本数据类型是按值访问的，存放在栈内存中 引用类型值是按引用访问的，存放在堆内存中 typeof能够返回 undefined null boolean string number object function 如何检测一个数组是数组？ instanceof 原型链方式 数组.proto.constructor===Array Object.prototype.toString.call(数组) Array.isArray() 内存泄漏 如果闭包的作用域链中保存着一个HTML 元素，那么就意味着该元素将无法被销毁 需要解除对DOM对象的引用 xss跨站脚本 反射型（非持久型） 对于 xss 反射型攻击，主要是诱使用户点击恶意的链接或者访问存在漏洞的内容，可以有如下方式： 攻击者可以将恶意链接直接发送给受信任用户，发送的方式有很多种，比如 email, 网站的私信、评论等 攻击者可以购买存在漏洞网站的广告，将恶意链接插入在广告的链接中 存储型（持久型）——&gt;&gt;&gt;输入检查 将一段恶意代码写在评论中，等待其他用户浏览评论时，就自动执行了js代码（获取cookie，并传输给攻击者的服务器）； 基于DOM ——&gt;&gt;&gt;输出检查 通过恶意脚本修改DOM结构 如何防范？ HttpOnly 防止劫取 Cookie 输入检查，对用户输入进行检查、过滤和转义 输出检查，在变量输出到html页面时，将其进行编码或转义 csrf跨站请求伪造 劫持受信任用户向服务器发送非预期请求 攻击者借助受害者的cookie骗取服务器的信任 涉及到浏览器的cookie策略 cookie有两种：会话期cookie和持久性cookie，后者可以指定过期时间 攻击者放了一个链接，这个链接指向一些删除操作，主要目的是改变服务器的数据 如何防范？ 验证码 referer check 在http请求头中的referer字段，表示该请求的来源地址 对每一个删帖请求，验证其referer值，如果该值指向其他网站，那就有可能是跨站伪请求 1234if (req.headers.referer !== '正确的站点地址') &#123; res.write('csrf 攻击'); return;&#125; 检查referer，还能防止图片盗链 当referer为空时, 返回正确的图；当referer不为空, 且host命中我的目标网站时, 返回正确的图；当referer不为空, 但host未能命中我的目标网站时, 返回错误的图 添加token验证 基本思路是在请求中添加一些攻击者无法伪造的信息，这些信息也不能存储在cookie中。在请求中添加一个类似随机数的token，服务器建立拦截器来验证","categories":[],"tags":[]},{"title":"二叉树与二叉查找树","slug":"二叉树与二叉查找树","date":"2018-12-09T06:40:25.000Z","updated":"2018-12-10T13:12:19.006Z","comments":true,"path":"2018/12/09/二叉树与二叉查找树/","link":"","permalink":"https://chenyongyang.github.io/2018/12/09/二叉树与二叉查找树/","excerpt":"","text":"什么是树？ 树由一组以边连接的节点组成 一棵树最上面的节点称为根节点 一个节点下面有多个节点，那这个节点被称为父节点 没有任何子节点的节点称为叶子节点 从一个节点到另一个节点的这一组边被称为路径 以某种顺序访问树中所有节点称为树的遍历 树的层数就是树的深度 每一个节点都有一个与之相关的值，这个值被称为键 二叉树是一种特殊的树，它的特点是子节点的个数不超过两个 二叉查找树是一种特殊的二叉树，特点是较小的值保存在左节点，较大的值保存在右节点 无论是二叉树还是二叉查找树，都是由节点组成的，因此我们首先定义Node节点类12345678910function Node(data, left, right)&#123; this.data = data this.left = left this.right = right this.show = show&#125;function show()&#123; return this.data&#125; 接下来就可以定义一棵二叉查找树了12345678910111213141516171819202122232425262728293031function BST()&#123; this.root = null this.insert = insert this.inOrder = inOrder&#125;function insert(data)&#123; let node = new Node(data, null, null) if(this.root == null)&#123; this.root = node &#125;else &#123; let current = this.root let parent while(true)&#123; parent = current if(data &lt; current.data)&#123; current = current.left if(current == null)&#123; parent.left = node break &#125; &#125;else&#123; current = current.right if (current == null) &#123; parent.right = node break &#125; &#125; &#125; &#125;&#125; 至此，我们已经能够向二叉树中插入节点了，我们还需要能够遍历这棵二叉树（以一定的顺序来显示节点） 遍历二叉树有三种方式：中序，先序，后序。其中，中序按节点键值的升序来遍历；先序则是先访问根节点，再访问左子树和右子树；后序则先访问叶子节点，然后是左子树、右子树、根节点12// 中序代码如下function","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://chenyongyang.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://chenyongyang.github.io/tags/数据结构/"}]},{"title":"数据结构篇——集合","slug":"数据结构篇——集合","date":"2018-12-09T05:52:54.000Z","updated":"2018-12-09T06:39:15.815Z","comments":true,"path":"2018/12/09/数据结构篇——集合/","link":"","permalink":"https://chenyongyang.github.io/2018/12/09/数据结构篇——集合/","excerpt":"","text":"集合中的元素被称为成员，这种数据结构有两个特点： 集合内的成员是无序的 集合内的成员不可重复 在这里我们用数组来实现集合Set类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394function Set() &#123; this.dataStore = [] this.add = add this.remove = remove this.size = size this.union = union this.intersect = intersect this.subset = subset this.difference = difference this.show = show&#125;function add(data)&#123; if(this.dataStore.indexOf(data) &lt; 0)&#123; this.dataStore.push(data) return true &#125;else &#123; return false &#125;&#125;function remove(data)&#123; let pos = this.dataStore.indexOf(data) if(pos &gt; -1) &#123; this.dataStore.splice(pos, 1) return true &#125;else &#123; return false &#125;&#125;// 判断一个元素是否在集合中function contains(data)&#123; if(this.dataStore.indexOf(data)&gt;-1)&#123; return true &#125;else &#123; return false &#125;&#125;// 合并两个集合function union(set)&#123; let tempSet = new Set() for(let i = o; i &lt; this.dataStore.length; i++)&#123; tempSet.add(this.dataStore[i]) &#125; for(let i = 0; i &lt; set.dataStore.length; ++i)&#123; if(!tempSet.contains(set.dataStore[i]))&#123; tempSet.add(set.dataStore[i]) &#125; &#125; return tempSet&#125;// 返回两个集合的交集function intersect(set)&#123; let tempSet = new Set() for(let i = 0; i &lt; this.dataStore.length; i++)&#123; if(set.contains(this.dataStore[i]))&#123; tempSet.add(this.dataStore[i]) &#125; &#125; return tempSet&#125;// 返回集合的长度function size()&#123; return this.dataStore.length&#125;// 判断一个集合是否是另一个集合的子集function subset(set)&#123; if(this.size() &gt; set.size())&#123; return false &#125;else &#123; for(let i of this.dataStore)&#123; if(!set.contains(i))&#123; return false &#125; &#125; &#125; return true&#125;// 返回两个集合的补集function difference(set)&#123; let tempSet = new Set() for(let i = 0; i &lt; this.dataStore.length; i++)&#123; if(!set.contains(this.dataStore[i]))&#123; tempSet.add(this.dataStore[i]) &#125; &#125; return tempSet&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://chenyongyang.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://chenyongyang.github.io/tags/数据结构/"}]},{"title":"数据结构篇——散列","slug":"数据结构篇——散列","date":"2018-12-02T07:03:22.000Z","updated":"2018-12-07T07:24:33.647Z","comments":true,"path":"2018/12/02/数据结构篇——散列/","link":"","permalink":"https://chenyongyang.github.io/2018/12/02/数据结构篇——散列/","excerpt":"","text":"散列后的数据可以快速插入或取用，散列使用的数据结构是散列表 适合插入、删除、取用数据；不适合查找 更现实的目标是：让散列函数尽量将键均匀地映射到数组中 两个键映射到同一个值的情况叫做碰撞 首先用一个HashTable的类来表示散列表，我们可以通过这个类来向散列插入新数据、从散列中读取数据、显示散列中数据分布、定义如何去计算散列值1234567function HashTable() &#123; this.table = new Array(137) // 这里数组的长度推荐是质数 this.simpleHash = simpleHash this.showDistro = showDistro this.put = put this.get = get&#125; 散列函数是这个过程的重点，它相当于一个信息压缩函数，将键（通常是字符串的形式）压缩成一个值（通常为数值形式） 散列函数定义如下：12345678910111213141516171819202122232425262728function simpleHash(data)&#123; let total = 0 for(let i = 0; i &lt; data.length; ++i)&#123; total += data.charCodeAt(i); &#125; return total % this.table.length&#125;function put(data)&#123; let pos = this.simpleHash(data) this.table[pos] = data&#125;function showDistro()&#123; for(let i = 0; i &lt; this.table.length; ++i)&#123; if(this.table[i] != undefined)&#123; console.log(i + \":\" + this.table[i]) &#125; &#125;&#125;// 测试代码let cities = ['shenzhen', 'beijing', 'guangzhou', 'shanghai']let hTable = new HashTable()for(let i = 0; i &lt; cities.length; ++i)&#123; hTable.put(cities[i])&#125;hTable.showDistro() 以上这种散列函数，会使得如果两个键所产生的散列值是相同的，那么只有一个能存入散列表，也就是发生了碰撞 我们可以通过改善散列函数来避免碰撞 需要从以下几个方面入手改善 数组的长度应该是质数 霍纳算法 使用霍纳算法来改善之前的散列函数123456789function betterHash(string, arr)&#123; const H = 37 let total = 0 for(let i = 0; i&lt; string.length; ++i)&#123; total += H * total + string.charCodeAt(i) // 区别是每次求和时都要乘以一个质数 &#125; total = total % arr.length return parseInt(total)&#125; 上面我们所散列化的键都是字符串类型，接下来要继续修改这个程序，使之可以散列化整型键1234567891011121314function getRandomInt(min, max)&#123; return Math.floor(Math.random()*(max - min + 1)) + min&#125;function genStuData(arr)&#123; for(let i = 0; i &lt; arr.length; ++i)&#123; let num = '' for(let j = 1; j &lt;= 9; ++j)&#123; num += Math.floor(Math.random()*10) &#125; num += getRandomInt(50, 100) arr[i] = num &#125;&#125; 同理使用betterHash得到散列值，以避免发生碰撞 普遍采用betterHash，所以重写put方法1234function put(key, data) &#123; let pos = this.betterHash(key) this.table[pos] = dataa&#125; 定义get方法，用来读取存储在散列表中的数据123function get(key) &#123; return this.table[this.betterHash(key)]&#125; 通过对键值进行散列，得到一个散列值，再通过这个散列值去散列表中读取对应的数据 接下来重点介绍如何解决碰撞 首先我们知道，当不同的输入通过散列函数后，得到相同的输出，这就是碰撞。解决碰撞一般有两种方式 开链法 线性探测法 开链法的重点是用来存储散列值的数组中每个元素，是一个新的数据结构，这样相同的输出也就能够共存了 相碰撞的两个散列值在第一数组的存储位置是相同的，不同的第二数组的位置，实现代码如下：12345function buildChains() &#123; for(let i = 0; i &lt; this.table.length; ++i) &#123; this.table[i] = new Array() &#125;&#125; 重新定义put方法1234567891011121314function put(key, data)&#123; let pos = this.betterHash(key) let index = 0 if(this.table[pos][index] == undefined) &#123; this.table[pos][index + 1] = data &#125; ++index else &#123; while (this.table[pos][index] != undefined)&#123; ++index &#125; this.table[pos][index+1] = data &#125;&#125; 重新定义get方法123456789101112131415function get(key)&#123; let index = 0 let hash = this.betterHash(key) if(this.table[hash][index] == key)&#123; return this.table[hash][index+1] &#125; index += 2 else &#123; while(this.table[pos][index] != key)&#123; index += 2 &#125; return this.table[hash][index+1] &#125; return undefined&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://chenyongyang.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://chenyongyang.github.io/tags/数据结构/"}]},{"title":"React组件——下拉刷新、上拉加载","slug":"React组件——下拉刷新、上拉加载","date":"2018-12-01T13:36:49.000Z","updated":"2018-12-01T13:42:09.877Z","comments":true,"path":"2018/12/01/React组件——下拉刷新、上拉加载/","link":"","permalink":"https://chenyongyang.github.io/2018/12/01/React组件——下拉刷新、上拉加载/","excerpt":"","text":"在移动端项目开发中，应用下拉刷新或上拉加载的场景非常多，避免编写重复代码，可以考虑把它封装成一个通用的组件，基于公司的技术栈，我们使用React来编写组件。 直接上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130import React from 'react'import _ from 'lodash'class PullFresh extends React.Component &#123; constructor (props) &#123; super(props) this.state = &#123; list: Array(50).fill(Math.ceil(Math.random() * 10)) &#125; this.dropPull = this.dropPull.bind(this) &#125; dropPull () &#123; let loadingText = this.refs.dropPull let _element = this.refs.refreshContainer let startPos = 0 let transitionHeight = 0 let startFlag = false let movingFlag = false _element.addEventListener('touchstart', e =&gt; &#123; // console.log('初始位置：', e.touches[0].pageY) if (this.getScrollTop() === 0) &#123; // 只有当滚动条处于顶部时，才触发下拉刷新的的动作 startFlag = true console.log('start') startPos = e.touches[0].pageY _element.style.position = 'relative' _element.style.transition = 'transform 0s' &#125; &#125;, true) _element.addEventListener('touchmove', e =&gt; &#123; console.log('moving') // console.log('当前位置：', e.touches[0].pageY) transitionHeight = e.touches[0].pageY - startPos // 获取下拉的距离 // console.log(transitionHeight) if (transitionHeight &gt; 0 &amp;&amp; transitionHeight &lt; 60) &#123; _element.style.transform = `translateY($&#123;transitionHeight&#125;px)` movingFlag = true &#125; if (transitionHeight &gt; 55) &#123; loadingText.innerText = '释放更新' &#125; &#125;, true) _element.addEventListener('touchend', e =&gt; &#123; console.log('end') if (startFlag &amp;&amp; movingFlag) &#123; // 只有当在顶部下拉且移动了一段距离，才触发动作 _element.style.transition = 'transform 0.5s ease' _element.style.transform = 'translateY(0px)' loadingText.innerText = '更新中...' console.log('获取上一页') startFlag = false movingFlag = false &#125; // console.log(transitionHeight) this.setState(&#123; list: Array(50).fill(Math.ceil(Math.random() * 10)) &#125;) &#125;, true) &#125; getScrollTop () &#123; let scrollTop = 0 if (document.documentElement &amp;&amp; document.documentElement.scrollTop) &#123; scrollTop = document.documentElement.scrollTop &#125; else if (document.body) &#123; scrollTop = document.body.scrollTop &#125; return scrollTop &#125; getClientHeight () &#123; let clientHeight = 0 if (document.body.clientHeight &amp;&amp; document.documentElement.clientHeight) &#123; clientHeight = Math.min(document.body.clientHeight, document.documentElement.clientHeight) &#125; else &#123; clientHeight = Math.max(document.body.clientHeight, document.documentElement.clientHeight) &#125; return clientHeight &#125; getScrollHeight () &#123; return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight) &#125; upPull () &#123; let _text = this.refs.upPull // let _container = this.refs.refreshContainer window.addEventListener('scroll', () =&gt; &#123; // console.log(Math.ceil(this.getScrollTop()) + this.getClientHeight() === this.getScrollHeight()) if (Math.ceil(this.getScrollTop()) + this.getClientHeight() === this.getScrollHeight()) &#123; _text.innerText = '加载中...' console.log('获取下一页数据') const newList = this.state.list newList.push(Math.ceil(Math.random() * 10), Math.ceil(Math.random() * 10), Math.ceil(Math.random() * 10)) setTimeout(() =&gt; &#123; this.setState(&#123; list: newList &#125;) &#125;, 1000) &#125; &#125;, true) &#125; componentDidMount () &#123; this.dropPull() this.upPull() &#125; render () &#123; return ( &lt;div&gt; &lt;p ref='dropPull'&gt;下拉刷新&lt;/p&gt; &lt;ul ref='refreshContainer'&gt; &#123; _.map(this.state.list, (item, key) =&gt; &#123; return ( &lt;li key=&#123;key&#125;&gt;&#123;item&#125;&lt;/li&gt; ) &#125;) &#125; &lt;/ul&gt; &lt;p ref='upPull'&gt;上拉加载&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;export default PullFresh","categories":[{"name":"React","slug":"React","permalink":"https://chenyongyang.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://chenyongyang.github.io/tags/React/"}]},{"title":"数据结构篇——散列","slug":"数据结构篇——散列","date":"2018-11-28T08:46:27.000Z","updated":"2018-11-28T14:04:04.266Z","comments":true,"path":"2018/11/28/数据结构篇——散列/","link":"","permalink":"https://chenyongyang.github.io/2018/11/28/数据结构篇——散列/","excerpt":"","text":"散列表是散列使用的数据结构","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://chenyongyang.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://chenyongyang.github.io/tags/数据结构/"}]},{"title":"性能优化之虚拟列表","slug":"性能优化之虚拟列表","date":"2018-11-27T13:39:04.000Z","updated":"2018-11-27T14:01:08.258Z","comments":true,"path":"2018/11/27/性能优化之虚拟列表/","link":"","permalink":"https://chenyongyang.github.io/2018/11/27/性能优化之虚拟列表/","excerpt":"","text":"在前端开发中，UI渲染一直都是重头戏。 我们可以回想一下，通常我们将一个DOM节点渲染到页面上，通常采用的方式有以下两种 innerHTML appendChild 这两种DOM渲染的方式之间的对比，网络上有很多分析的文章，这里不再赘述 总的来说，两者对性能的影响差异不大，可以忽略不计 既然对性能影响不大，那我们还讨论什么呢？ 我们在开发的时候，通常遇到这个场景，后端返回json格式的数据，前端拿到数据自然是渲染，当然在渲染前可能会作一些处理 如果数据量小的话，那还好办直接对数据进行循环遍历就是了；问题是当返回的数据量很大时，我们该怎么办？ 特别是在移动端，对于性能的要求比较高，如果将大量的数据一次性渲染出来，很可能会出现卡死、白屏、甚至浏览器会崩溃 我们常见的做法是延迟加载，或叫无限滚动，原理也就是根据滚动条滚动的距离，来判断用户浏览当前网页的位置，监听滚动事件，从而当滚动条到达合适的距离，触发回调向后端发起请求，后端返回数据后再渲染出来 这种解决问题的思路是从数据入手，也就是对数据进行几次分割，每次只是请求部分数据，这样渲染的压力就减小很多 传统PC端的分页也是相似的原理，区别只在于分页会导致页面全部刷新，而无限滚动只是局部刷新，后者用户体验更好 我们今天的主角：虚拟列表。它所要解决的问题也是前面提到的大量DOM渲染开销大的问题，区别于上面的解决手段，它的思路是从UI入手 它的原理是这样的：当我们在浏览网页时，其实看到的只是浏览器视窗范围的内容，超出视窗的内容我们是看不到的 那既然这样，我们在渲染DOM时，就只需要渲染用户当前看的部分，其他的都可以不用渲染了 说到这里，我们就知道要实现虚拟列表，很关键的一点就是高度问题。这里的高度包括浏览器视窗的高度，列表每一项的高度。根据这些高度，我们才可以判断究竟要渲染列表中的哪一项到哪一项。 当时要用到公司的业务中，肯定需要借助市面上成熟的类库，因为技术栈是React，所以这里以react-virtualized为例，来分析其具体技术实现","categories":[{"name":"性能优化","slug":"性能优化","permalink":"https://chenyongyang.github.io/categories/性能优化/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://chenyongyang.github.io/tags/性能优化/"}]},{"title":"不要写重复代码","slug":"不要写重复代码","date":"2018-11-25T06:49:09.000Z","updated":"2018-11-25T06:54:30.243Z","comments":true,"path":"2018/11/25/不要写重复代码/","link":"","permalink":"https://chenyongyang.github.io/2018/11/25/不要写重复代码/","excerpt":"","text":"在项目开发的过程中，我们会遇到很多编写重复代码的场景 那应该如何解决呢？ 首先想到的是循环，可以将要渲染的“数据”提取出来，用数组这种数据结构来存储（只是为了更好地遍历），然后使用map等方法进行渲染 多处用到循环，每个循环的结构好像都差不多，那我们就可以考虑将循环用函数封装起来 能提取就提取，能封装就封装，别到处都是重复的代码","categories":[],"tags":[]},{"title":"git 拉取远程分支到本地","slug":"git拉取远程分支到本地","date":"2018-11-22T07:59:29.000Z","updated":"2018-11-22T08:00:37.670Z","comments":true,"path":"2018/11/22/git拉取远程分支到本地/","link":"","permalink":"https://chenyongyang.github.io/2018/11/22/git拉取远程分支到本地/","excerpt":"","text":"git pull origin 远程分支名:本地分支名","categories":[{"name":"Git","slug":"Git","permalink":"https://chenyongyang.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://chenyongyang.github.io/tags/Git/"}]},{"title":"git rebase常见坑点","slug":"git rebase常见坑点","date":"2018-11-22T07:28:48.000Z","updated":"2018-11-22T08:00:46.415Z","comments":true,"path":"2018/11/22/git rebase常见坑点/","link":"","permalink":"https://chenyongyang.github.io/2018/11/22/git rebase常见坑点/","excerpt":"","text":"在公司开发项目，经常会出现自己的开发分支处于灰度状态，灰度确定没有问题后，准备全量时，因为有可能别人在你灰度的这段时间中，提交了一些代码，所以需要先更新一下master的代码，也就是执行git rebase -i master。这个命令用得很频繁，但是每次使用都好像不是那么顺利。其中比较麻烦的也就是代码冲突的解决。 解决冲突，首先要看什么是master上的代码，什么是开发分支上的代码 然后比较两者的差异，确定要留下哪部分代码 总之就是解决冲突时要谨慎、仔细","categories":[{"name":"Git","slug":"Git","permalink":"https://chenyongyang.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://chenyongyang.github.io/tags/Git/"}]},{"title":"为什么会出现^m？","slug":"为什么会出现^m？","date":"2018-11-15T13:50:03.000Z","updated":"2018-11-22T07:40:47.355Z","comments":true,"path":"2018/11/15/为什么会出现^m？/","link":"","permalink":"https://chenyongyang.github.io/2018/11/15/为什么会出现^m？/","excerpt":"","text":"这个问题还得从编程环境说起 公司是在mac系统下编码，我自己的电脑是windows系统 当我想着把公司的项目带回学校自己做时，并没有发现任何问题 但是当第二天到了公司，准备将代码提交上去时，惊奇地发现所有在学校改过的文件，git diff都显示修改过，而事实上我只是改动了一两行而已，git diff显示的是整个文件都被改动过了 这样就会导致一个问题，git diff变得没有意义了；同时以后同事要提交代码，都会出现冲突，这个问题不可小视 通过查找资料，最终得知是换行符的不同导致的，简单讲就是windows系统的换行符和mac系统的换行符不一样 通过vim编辑器打开，我们也可以看到每一行末尾都有^m这个标记 所以解决问题的方法就是去掉文件每一行末尾的^m标记 方式也有很多，常见的有dos2unix、用vim命令来匹配字符然后去掉 一行命令解决的事，绝不用两行 find js/ -name “*.js” | xargs dos2unix","categories":[{"name":"vim","slug":"vim","permalink":"https://chenyongyang.github.io/categories/vim/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://chenyongyang.github.io/tags/vim/"}]},{"title":"数据结构篇——字典","slug":"数据结构篇——字典","date":"2018-11-10T12:05:15.000Z","updated":"2018-11-11T03:09:06.330Z","comments":true,"path":"2018/11/10/数据结构篇——字典/","link":"","permalink":"https://chenyongyang.github.io/2018/11/10/数据结构篇——字典/","excerpt":"","text":"字典是一种以键值对形式存储数据的数据结构，JavaScript的Object类就是以字典的形式设计的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function Dictionary()&#123; this.dataStore = new Array(); this.add = add; this.find = find; this.remove = remove; this.showAll = showAll; this.count = count; this.clear = clear;&#125;// 向字典中添加键值对function add(key, value)&#123; this.dataStore[key] = value;&#125;// 通过键返回值function find(key)&#123; return this.dataStore[key];&#125;// 通过键删除键值对function remove(key)&#123; delete this.dataStore[key];&#125;function showAll() &#123; if (Object.keys(this.dataStore).length == 0)&#123; console.log('null') &#125; for (let key of Object.keys(this.dataStore).sort()) &#123; // 对键值进行排序 console.log(key + '-&gt;' + this.dataStore[key]); &#125;&#125;function count()&#123; return Object.keys(this.dataStore).length; // 方法二 // let n = 0; // for (let key in Object.keys(this.dataStore))&#123; // n++; // &#125; // return n;&#125;function clear()&#123; for(let key of Object.keys(this.dataStore))&#123; delete this.dataStore[key]; &#125;&#125;// 测试代码let book = new Dictionary();book.add('c', '1');book.add('b', '2');book.add('a', '3');console.log('a的值为：'+book.find('a'));book.remove('b')console.log(book.count());book.showAll();book.clear();book.showAll();console.log(book.count());","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://chenyongyang.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://chenyongyang.github.io/tags/数据结构/"}]},{"title":"数据结构篇——双向链表","slug":"数据结构篇——双向链表","date":"2018-11-10T06:42:38.000Z","updated":"2018-11-10T07:12:19.922Z","comments":true,"path":"2018/11/10/数据结构篇——双向链表/","link":"","permalink":"https://chenyongyang.github.io/2018/11/10/数据结构篇——双向链表/","excerpt":"","text":"双向链表给链上的每个节点增加了一个指向前驱节点的链接，使得从后向前遍历链表时变得简单；同时删除节点时，也不用像单向链表那样寻找待删除节点的前驱节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// 基于链表都是由节点组成的，我们需要定义一个节点类function Node(element)&#123; this.element = element; // 保存节点上的数据 this.next = null; // 保存指向下一个节点的链接 this.prev = null; // 保存指向上一个节点的链接&#125;// 实现链表类function LList()&#123; this.head = new Node('head'); this.find = find; this.findLast = findLast; this.insert = insert; this.display = display; this.remove = remove; this.reverse = reverse;&#125;// 插入新节点，需要知道在哪个节点前面或后面插入// 因此首先要找到一个已知节点function find(item)&#123; let currNode = this.head; while (currNode.element != item)&#123; currNode = currNode.next; &#125; return currNode;&#125;// 找到最后一个节点function findLast()&#123; let currNode = this.head; while (currNode.next != null) &#123; currNode = currNode.next; &#125; return currNode;&#125;// 找到插入的相对点后，设置新节点的前后指向function insert(newElement, item)&#123; let newNode = new Node(newElement); let current = this.find(item); newNode.next = current.next; newNode.prev = current; current.next = newNode;&#125;// 展示链表所有节点(不显示头节点)function display()&#123; let currNode = this.head; while (currNode.next != null)&#123; console.log(currNode.next.element); currNode = currNode.next; &#125;&#125;// 直接找到待删除节点，更改前后指向function remove(item)&#123; let currNode = this.find(item); if(currNode.next != null)&#123; currNode.prev.next = currNode.next; currNode.next.prev = currNode.prev; currNode.prev = null; currNode.next = null; &#125;&#125;function reverse()&#123; let currNode = this.findLast(); while(currNode.prev != null)&#123; console.log(currNode.element); currNode = currNode.prev; &#125;&#125;// 测试代码let llist = new LList()llist.insert(\"a\", \"head\")llist.insert(\"b\", \"a\")llist.insert(\"c\", \"b\")llist.insert(\"d\", \"c\")console.log(llist.findLast())llist.display()console.log('------')llist.reverse()console.log('------')llist.remove(\"c\")llist.display()","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://chenyongyang.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://chenyongyang.github.io/tags/数据结构/"}]},{"title":"数据结构篇——单向链表","slug":"数据结构篇——单向链表","date":"2018-11-10T02:45:36.000Z","updated":"2018-11-10T07:12:28.279Z","comments":true,"path":"2018/11/10/数据结构篇——单向链表/","link":"","permalink":"https://chenyongyang.github.io/2018/11/10/数据结构篇——单向链表/","excerpt":"","text":"在JavaScript中，由于数组被实现为对象，与其他语言相比效率很低。当我们发觉使用数组时运行效率很慢，那么就应该考虑链表。 链表是由一组节点组成的集合，每个节点都使用一个对象的引用来指向它后面的节点，这个指向后面节点的引用就被称为链。 数组和链表的区别： 数组靠位置来引用，链表靠节点之间的相互关系来引用 遍历链表时不包含头节点，头节点作为链表的接入点；链表的尾元素指向一个null节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 基于链表都是由节点组成的，我们需要定义一个节点类function Node(element)&#123; this.element = element; // 保存节点上的数据 this.next = null; // 保存指向下一个节点的链接&#125;// 实现链表类function LList()&#123; this.head = new Node('head'); this.find = find; this.insert = insert; this.display = display; this.findPrevious = findPrevious; this.remove = remove;&#125;// 插入新节点，需要知道在哪个节点前面或后面插入// 因此首先要找到一个已知节点function find(item)&#123; let currNode = this.head; while (currNode.element != item)&#123; currNode = currNode.next; &#125; return currNode;&#125;// 找到插入的相对点后，就可以插入节点了function insert(newElement, item)&#123; let newNode = new Node(newElement); let current = this.find(item); newNode.next = current.next; current.next = newNode;&#125;// 展示链表所有节点(不显示头节点)function display()&#123; let currNode = this.head; while (currNode.next != null)&#123; console.log(currNode.next.element); currNode = currNode.next; &#125;&#125;// 从链表中删除节点// 首先要找到待删除节点的前一个节点，让这个节点的next属性不再指向待删除节点，而是指向待删除节点的下一个节点function findPrevious(item)&#123; let currNode = this.head; while(currNode.next != null &amp;&amp; currNode.next.element != item)&#123; currNode = currNode.next; &#125; return currNode;&#125;// 找到待删除节点的前一个节点后，就可以删除节点了function remove(item)&#123; let prevNode = this.findPrevious(item); if(prevNode.next != null)&#123; // prevNode.next = item.next; 这样写是错的，因为item是节点的elment属性的值，并不是节点本身 prevNode.next = prevNode.next.next; &#125;&#125;// 测试代码let llist = new LList();llist.insert(\"a\", \"head\");llist.insert(\"b\", \"a\");llist.insert(\"c\", \"b\");llist.insert(\"d\", \"c\");llist.display();llist.remove(\"c\");llist.display();","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://chenyongyang.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://chenyongyang.github.io/tags/数据结构/"}]},{"title":"数据结构篇——队列","slug":"数据结构篇——队列","date":"2018-11-08T07:30:32.000Z","updated":"2018-11-08T07:51:04.217Z","comments":true,"path":"2018/11/08/数据结构篇——队列/","link":"","permalink":"https://chenyongyang.github.io/2018/11/08/数据结构篇——队列/","excerpt":"","text":"队列用于存储按顺序排列的数据，是一种先进先出的数据结构，最后入栈的元素反而被优先处理 应用场景 提交操作系统执行的一系列进程 打印任务池 模拟银行的仿真系统 等等 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function Queue() &#123; this.dataStore = []; this.enqueue = enqueue; this.dequeue = dequeue; this.front = front; this.back = back; this.toString = toString; this.empty = empty;&#125;// 向队尾添加一个元素function enqueue(element)&#123; this.dataStore.push(element)&#125;// 删除队尾元素function dequeue()&#123; return this.dataStore.shift()&#125;// 读取队首、队尾元素function front()&#123; return this.dataStore[0]&#125;function back()&#123; return this.dataStore[this.dataStore.length-1]&#125;function toString()&#123; let str = '' for(let i = 0; i &lt; this.dataStore.length; ++i)&#123; str += this.dataStore[i] + '\\n' &#125; return str&#125;function empty()&#123; if(this.dataStore.length == 0)&#123; return true &#125;else&#123; return false &#125;&#125;// 测试代码let q = new Queue()q.enqueue('a')q.enqueue('b')q.enqueue('c')console.log(q.toString())q.dequeue()console.log(q.toString())console.log(q.front())console.log(q.back())","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://chenyongyang.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://chenyongyang.github.io/tags/数据结构/"}]},{"title":"前端安全篇——XSS","slug":"前端安全篇——XSS","date":"2018-11-06T13:34:38.000Z","updated":"2018-11-13T01:21:38.517Z","comments":true,"path":"2018/11/06/前端安全篇——XSS/","link":"","permalink":"https://chenyongyang.github.io/2018/11/06/前端安全篇——XSS/","excerpt":"","text":"XSS","categories":[{"name":"前端安全","slug":"前端安全","permalink":"https://chenyongyang.github.io/categories/前端安全/"}],"tags":[{"name":"前端安全","slug":"前端安全","permalink":"https://chenyongyang.github.io/tags/前端安全/"}]},{"title":"算法排序篇——快速排序","slug":"算法排序篇——快速排序","date":"2018-11-04T07:53:00.000Z","updated":"2018-11-04T08:58:35.974Z","comments":true,"path":"2018/11/04/算法排序篇——快速排序/","link":"","permalink":"https://chenyongyang.github.io/2018/11/04/算法排序篇——快速排序/","excerpt":"","text":"1234567891011121314151617181920212223242526function quickSort(arr) &#123; if(arr.length == 0)&#123; return []; // 控制递归的终止 &#125; let lesser = [], greater = [], pivot = arr[0]; // 一般将第一个或最后一个作为基准数 for (let i = 1; i &lt;= arr.length - 1; i++) &#123; // 因为基准数是第一个数，循环从第二个数开始 if (arr[i] &lt; pivot) &#123; lesser.push(arr[i]); &#125; else &#123; greater.push(arr[i]); &#125; &#125; // 对子序列进行以上操作，通过递归实现 return quickSort(lesser).concat(pivot, quickSort(greater));&#125;// 测试代码let arr = [];for (let i = 0; i &lt; 10; ++i) &#123; arr[i] = Math.floor((Math.random() * 100) + 1);&#125;console.log(arr);console.log(quickSort(arr));","categories":[{"name":"算法","slug":"算法","permalink":"https://chenyongyang.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://chenyongyang.github.io/tags/算法/"}]},{"title":"算法排序篇——插入排序","slug":"算法排序篇——插入排序","date":"2018-11-04T07:05:05.000Z","updated":"2018-11-04T08:58:31.777Z","comments":true,"path":"2018/11/04/算法排序篇——插入排序/","link":"","permalink":"https://chenyongyang.github.io/2018/11/04/算法排序篇——插入排序/","excerpt":"","text":"123456789101112131415function insertSort(arr)&#123; // 假设第一个数是已排序的，那么未排序就从第二个数开始，依次从未排序数组中取值，到已排序数组中比较 for(let outer = 1; outer &lt;= arr.length -1; outer++)&#123; // 将未排序的数遍历已排序的数组 for(let inner = 0; inner &lt;= outer -1; inner++)&#123; // 如果未排序的数比已排序的数小，这里有个技巧，直接从前往后遍历，就可以直接将要插入的值用splice插入 if(arr[outer] &lt; arr[inner])&#123; // 插入到已排序的、比它大的数的前面 arr.splice(inner, 0, arr[outer]); // 将其自身从未排序数组中删除，这里的outer + 1是因为，前面执行了添加，导致数组都整体往后移动一位，所以被插入的数组索引加一 arr.splice(outer + 1, 1); &#125; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://chenyongyang.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://chenyongyang.github.io/tags/算法/"}]},{"title":"算法排序篇——选择排序","slug":"算法排序篇——选择排序","date":"2018-11-04T02:55:47.000Z","updated":"2018-11-04T08:57:50.400Z","comments":true,"path":"2018/11/04/算法排序篇——选择排序/","link":"","permalink":"https://chenyongyang.github.io/2018/11/04/算法排序篇——选择排序/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576function CArray(numElements) &#123; this.dataStore = []; this.pos = 0; this.numElements = numElements; this.insert = insert; this.toString = toString; this.clear = clear; this.setData = setData; this.swap = swap; this.bubbleSort = bubbleSort; this.selectSort = selectSort; for (let i = 0; i &lt; numElements; ++i) &#123; this.dataStore[i] = i; &#125; function setData() &#123; for (let i = 0; i &lt; this.numElements; ++i) &#123; this.dataStore[i] = Math.floor(Math.random() * (this.numElements + 1)); &#125; &#125; function clear() &#123; for (let i = 0; i &lt; this.dataStore.length; ++i) &#123; this.dataStore[i] = 0; &#125; &#125; function insert(element) &#123; this.dataStore[this.pos++] = element; &#125; function toString() &#123; let str = ''; for (let i = 0; i &lt; this.dataStore.length; ++i) &#123; str += this.dataStore[i] + ' '; // 每逢十个换行 if (i &gt; 0 &amp; i % 10 == 0) &#123; str += '\\n'; &#125; &#125; return str; &#125; function swap(arr, index1, index2) &#123; let temp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = temp; &#125; function bubbleSort() &#123; let numElements = this.dataStore.length; let temp; // 外循环用于遍历数组中的每一项元素 for (let outer = numElements; outer &gt;= 2; --outer) &#123; // 内循环用于比较元素 for (let inner = 0; inner &lt;= outer - 1; ++inner) &#123; if (this.dataStore[inner] &gt; this.dataStore[inner + 1]) &#123; swap(this.dataStore, inner, inner + 1); &#125; &#125; &#125; &#125; function selectSort() &#123; let min; for (let outer = 0; outer &lt;= this.dataStore.length - 2; ++outer) &#123; min = outer; for (let inner = outer + 1; inner &lt;= this.dataStore.length - 1; ++inner) &#123; if (this.dataStore[inner] &lt; this.dataStore[min]) &#123; swap(this.dataStore, inner, min); &#125; &#125; &#125; &#125;&#125;// 测试代码let numElements = 10;let myNums = new CArray(numElements);myNums.setData();console.log(myNums.toString());myNums.selectSort();console.log(myNums.toString());","categories":[{"name":"算法","slug":"算法","permalink":"https://chenyongyang.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://chenyongyang.github.io/tags/算法/"}]},{"title":"算法排序篇——冒泡排序","slug":"算法排序篇——冒泡排序","date":"2018-11-04T02:30:50.000Z","updated":"2018-11-04T08:58:40.006Z","comments":true,"path":"2018/11/04/算法排序篇——冒泡排序/","link":"","permalink":"https://chenyongyang.github.io/2018/11/04/算法排序篇——冒泡排序/","excerpt":"","text":"冒泡排序是最慢的排序算法之一，也是最容易实现的排序算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566function CArray(numElements) &#123; this.dataStore = []; this.pos = 0; this.numElements = numElements; this.insert = insert; this.toString = toString; this.clear = clear; this.setData = setData; this.swap = swap; this.bubbleSort = bubbleSort; for (let i = 0; i &lt; numElements; ++i) &#123; this.dataStore[i] = i; &#125; function setData() &#123; for (let i = 0; i &lt; this.numElements; ++i)&#123; this.dataStore[i] = Math.floor(Math.random() * (this.numElements + 1)); &#125; &#125; function clear()&#123; for(let i = 0; i&lt;this.dataStore.length; ++i)&#123; this.dataStore[i] = 0; &#125; &#125; function insert(element)&#123; this.dataStore[this.pos++] = element; &#125; function toString()&#123; let str = ''; for(let i = 0; i&lt;this.dataStore.length; ++i)&#123; str += this.dataStore[i] + ' '; // 每逢十个换行 if(i &gt; 0 &amp; i % 10 == 0)&#123; str+='\\n'; &#125; &#125; return str; &#125; function swap(arr, index1, index2)&#123; let temp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = temp; &#125; function bubbleSort() &#123; let numElements = this.dataStore.length; let temp; // 外循环用于遍历数组中的每一项元素 for (let outer = numElements; outer &gt;= 2; --outer) &#123; // 内循环用于比较元素 for (let inner = 0; inner &lt;= outer - 1; ++inner) &#123; if (this.dataStore[inner] &gt; this.dataStore[inner + 1]) &#123; swap(this.dataStore, inner, inner + 1); // console.log(this.dataStore) &#125; &#125; console.log(this.toString()) &#125; &#125;&#125;// 测试代码let numElements = 10;let myNums = new CArray(numElements);myNums.setData();console.log(myNums.toString());myNums.bubbleSort();console.log(myNums.toString());","categories":[{"name":"算法","slug":"算法","permalink":"https://chenyongyang.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://chenyongyang.github.io/tags/算法/"}]},{"title":"算法排序篇——数组测试平台","slug":"算法排序篇——数组测试平台","date":"2018-11-03T02:48:26.000Z","updated":"2018-11-04T08:58:43.674Z","comments":true,"path":"2018/11/03/算法排序篇——数组测试平台/","link":"","permalink":"https://chenyongyang.github.io/2018/11/03/算法排序篇——数组测试平台/","excerpt":"","text":"准备一个数组测试平台123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function CArray(numElements) &#123; this.dataStore = []; this.pos = 0; this.numElements = numElements; this.insert = insert; this.toString = toString; this.clear = clear; this.setData = setData; this.swap = swap; for (let i = 0; i &lt; numElements; ++i) &#123; this.dataStore[i] = i; &#125; function setData() &#123; for (let i = 0; i &lt; this.numElements; ++i)&#123; this.dataStore[i] = Math.floor(Math.random() * (this.numElements + 1)); &#125; &#125; function clear()&#123; for(let i = 0; i&lt;this.dataStore.length; ++i)&#123; this.dataStore[i] = 0; &#125; &#125; function insert(element)&#123; this.dataStore[this.pos++] = element; &#125; function toString()&#123; let str = ''; for(let i = 0; i&lt;this.dataStore.length; ++i)&#123; str += this.dataStore[i] + ' '; // 每逢十个换行 if(i &gt; 0 &amp; i % 10 == 0)&#123; str+='\\n'; &#125; &#125; return str; &#125; function swap(arr, index1, index2)&#123; let temp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = temp; &#125;&#125;// 测试代码let numElements = 100;let myNums = new CArray(numElements);myNums.setData();console.log(myNums.toString())","categories":[{"name":"算法","slug":"算法","permalink":"https://chenyongyang.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://chenyongyang.github.io/tags/算法/"}]},{"title":"从周报中获得什么","slug":"从周报中获得什么","date":"2018-11-02T13:49:25.000Z","updated":"2018-11-02T13:59:52.365Z","comments":true,"path":"2018/11/02/从周报中获得什么/","link":"","permalink":"https://chenyongyang.github.io/2018/11/02/从周报中获得什么/","excerpt":"","text":"需求：进入详情页后，返回之前的列表页，需要自动定位到上一次浏览的位置 这里的解决方法是：将详情页独立为一个浮层，通过URL的参数来唤起这个浮层也就是详情页，点击返回时关闭浮层，整个过程背后都是列表页，这就决定了详情页（浮层）不参与路由 问题：当用户退出当前账户后重新进入时，购物车的数据被清空了 分析：现在购物车数据的存储一般都是利用session，这就涉及到session的生命周期 当用户退出登录重新登录时，如果cookies没有清除，那么还可以通过sessionId获取用户存储在服务器端的session数据 如果cookies被清除了，也只是清除了存储在其中的sessionId，session对象还不会被马上清除 那session对象什么时候被清除呢？ 服务器不知道浏览器已经将sessionId清除了，相当于这段session已经失效了，因此它会给session设置一个过期日期，逾期就将session清除 回到问题，也就是其实就是用户退出后，还将cookies给清除了，那这样自然就无法取到存储在session的数据了 关于react性能优化的几个点 开启render插件，避免无关节点的渲染 将组件分割得更细，让组件的颗粒度更小，这样当数据更新，组件重新渲染的时候，就可以减少渲染的节点","categories":[{"name":"周报总结","slug":"周报总结","permalink":"https://chenyongyang.github.io/categories/周报总结/"}],"tags":[{"name":"周报总结","slug":"周报总结","permalink":"https://chenyongyang.github.io/tags/周报总结/"}]},{"title":"高效学习","slug":"高效学习","date":"2018-11-01T13:18:43.000Z","updated":"2018-11-01T13:43:02.370Z","comments":true,"path":"2018/11/01/高效学习/","link":"","permalink":"https://chenyongyang.github.io/2018/11/01/高效学习/","excerpt":"","text":"整体性学习获取：准确、压缩 理解：放在上下文中联系 拓展 怎么来的？其中每个成分的本质？可以做哪些改变？改变会导致什么结果？与同类的相同、不同点？ 深度拓展：知识的背景 横向拓展：与相似的做类比 纵向拓展：与不相关的建立联系 纠错：删除无效连接 应用 测试","categories":[{"name":"学习策略","slug":"学习策略","permalink":"https://chenyongyang.github.io/categories/学习策略/"}],"tags":[{"name":"学习策略","slug":"学习策略","permalink":"https://chenyongyang.github.io/tags/学习策略/"}]},{"title":"数据结构篇——栈","slug":"数据结构篇——栈","date":"2018-11-01T08:57:45.000Z","updated":"2018-11-08T07:29:55.657Z","comments":true,"path":"2018/11/01/数据结构篇——栈/","link":"","permalink":"https://chenyongyang.github.io/2018/11/01/数据结构篇——栈/","excerpt":"","text":"栈是一种高效的数据结构，特点是只能在栈顶进行添加或删除操作，具有后入先出的特点，任何不在栈顶的元素都无法被访问。123456789101112131415161718192021222324252627282930313233343536373839404142function Stack()&#123; this.dataStore = []; this.top = 0; // 记录栈顶的位置 this.push = push; this.pop = pop; this.peek = peek; this.clear = clear; this.length = length;&#125;function push(element)&#123; this.dataStore[this.top++] = element;&#125;function pop()&#123; // 返回并删除栈顶元素 return this.dataStore[--this.top];&#125;function peek()&#123; // 返回栈顶元素 return this.dataStore[this.top-1];&#125;function length()&#123; return this.top;&#125;function clear()&#123; this.top = 0;&#125;// 测试代码let s = new Stack();s.push('a');s.push('b');s.push('c');console.log(s.length())console.log(s.peek())s.push('d');console.log(s.peek());s.clear();console.log(s.length());console.log(s.peek());","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://chenyongyang.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://chenyongyang.github.io/tags/数据结构/"}]},{"title":"数据结构篇——列表","slug":"数据结构篇——列表","date":"2018-11-01T07:05:12.000Z","updated":"2018-11-08T07:37:02.699Z","comments":true,"path":"2018/11/01/数据结构篇——列表/","link":"","permalink":"https://chenyongyang.github.io/2018/11/01/数据结构篇——列表/","excerpt":"","text":"列表是一种最自然的数据组织方式 列表适用的场景 对元素的存储顺序没有要求 不需要查找或者排序 即数据结构比较简单的时候 下面是用JavaScript实现的一个列表类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136function List()&#123; this.listSize = 0; this.pos = 0; this.length = length this.dataStore = []; this.clear = clear; this.find = find; this.toString = toString; this.insert = insert; this.append = append; this.remove = remove; this.front = front; this.end = end; this.prev = prev; this.next = next; this.currPos = currPos; this.moveTo = moveTo; this.getElement = getElement; this.contains = contains;&#125;// 给列表添加元素function append(element)&#123; // 先返回原来的listSize作为新元素的索引，在自增1 this.dataStore[this.listSize++] = element;&#125;// 删除列表元素// 要删除首先要找到删除对象function find(element)&#123; for(let i = 0; i &lt; this.dataStore.length; i++)&#123; if(this.dataStore[i] == element)&#123; return i; &#125; return -1; &#125;&#125;function remove(element)&#123; let index = this.find(element); if(index &gt; -1)&#123; this.dataStore.splice(index, 1); --this.listSize; return true; &#125; return false;&#125;function length()&#123; return this.listSize;&#125;function toString()&#123; return this.dataStore;&#125;function insert(element, after)&#123; let insertPos = this.find(after); if(insertPos &gt; -1)&#123; this.dataStore.splice(insertPos+1, 0, element); ++this.dataStore; return true; &#125; return false;&#125;function clear()&#123; delete this.dataStore; this.dataStore = []; this.listSize = this.pos = 0;&#125;function contains(element)&#123; for(let i = 0; i &lt; this.dataStore.length; i++)&#123; if(this.dataStore[i] == element)&#123; return true; &#125; &#125; return false;&#125;function front()&#123; this.pos = 0;&#125;function end()&#123; this.pos = this.listSize - 1;&#125;function prev()&#123; if(this.pos &gt; 0)&#123; --this.pos; &#125;&#125;function next()&#123; if(this.pos &lt; this.listSize - 1)&#123; ++this.pos; &#125;&#125;function currPos()&#123; return this.pos;&#125;function moveTo(position)&#123; this.pos = position;&#125;function getElement()&#123; return this.dataStore[this.pos];&#125;// 测试代码let names = new List();names.append('a');names.append('b');names.append('c');names.append('d');names.append('e');names.front();console.log(names.getElement());names.next();names.next();names.prev();console.log(names.getElement());// 使用迭代器访问列表// 从前往后遍历for(names.front(); names.currPos() &lt; names.length(); names.next())&#123; console.log(names.getElement())&#125;// 从后往前遍历for (names.end(); names.currPos() &gt;= 0; names.prev()) &#123; console.log(names.getElement())&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://chenyongyang.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://chenyongyang.github.io/tags/数据结构/"}]},{"title":"计算机网络——TCP","slug":"计算机网络——TCP","date":"2018-10-30T13:57:16.000Z","updated":"2018-11-08T07:34:07.213Z","comments":true,"path":"2018/10/30/计算机网络——TCP/","link":"","permalink":"https://chenyongyang.github.io/2018/10/30/计算机网络——TCP/","excerpt":"","text":"IP协议只是让两台主机连接起来，数据只是到了主机这个层面，数据真正的通信的主体是主机中的进程 TCP连接是更进一步的连接，是端对端的通信、应用进程之间的通信 首先需要了解TCP报文的一些字段的含义，这对后面的理解非常关键 SYN：建立连接 ACK：响应 FIN：关闭连接 PSH：有DATA数据传输 RST：连接重置 这几个字段都可以组合使用，例如：单独SYN为1时，表示请求建立连接；SYN和ACK都为1时，表示发送连接请求之后的响应；关闭连接的FIN的组合同理 TCP建立连接三次握手过程TCP服务器进程建立TCB传输控制块（被动打开），准备接收客户进程的连接请求，此时服务器进入LISTEN监听状态 第一次：TCP客户进程建立TCB传输控制块（主动打开），向服务器进程发送连接请求报文。报文首部包含一个同步位SYN=1，并选择一个初始序列号seq=x，此时TCP客户端进程进入SYN-SENT同步已发送状态 第二次：TCP服务器进程接收到请求报文后，如果同意连接，就发送确认报文。报文首部包含同步位SYN=1,ACK=1，确认号ack=x+1,自己也要初始化一个序列号seq=y,此时服务器进入SYN-RCVD同步收到状态，之所以自己还要发送一个序列号，这是规定 第三次：客户端进程接收到确认报文后，发送确认报文给服务器进程ACK=1，序列号seq=x+1,确认号ack=y+1 连接确立，客户端进程进入ESTABILISH已建立连接状态，双方可以开始通信 假设就执行的是两次握手的流程，客户端进程发送请求，服务器端进程接收后确认，连接就确立。那么假如客户端进程向服务器端进程发送一条请求，由于各种原因，请求很慢才到达服务器端进程，客户端进程以为服务器端接收不到，又重新发了一次，服务器端接收到后确认建立连接，这次连接就算完成了；但是第一次发送的还在路上的请求到了服务器端那边，服务器端又接收、确立，建立连接，显然第二次连接是重复的，这是不必要的资源浪费 如果是三次握手，那么当服务器端接收到第二次重复请求时，发送确认报文给客户端，但客户端并没有发送确认报文，服务器端就会认为客户端并没有这个请求，也就是识别到这是个无效请求，之间也就不会建立连接 传输过程中的seq和ack代表什么？ seq是数据包本身的序列号；ack是期望对方继续发送的那个数据包的序列号。 TCP连接四次挥手的过程 首先应该明确客户端进程主动关闭连接，而服务器端进程被动关闭连接 第一次：客户端进程发送连接释放报文 FIN=1，并发送初始序列号seq=u,此时客户端进程进入FIN-WAIT-1状态，客户端进程不再发送数据 第二次：服务器端进程接收到释放报文后，返回一个确认报文ACK=1 ack=u+1 seq=v 此时服务器端进程进入CLOSE-WAIT状态，同时通知高层的应用进程，此时服务器端进程仍可以发送数据， 客户端进程接收到服务器端进程的确认报文后，进入FIN-WAIT-2，等待服务器端进程发送连接释放报文 第三次：等到服务器端进程数据发送完毕后，发送连接释放报文，FIN=1 ACK=1 ack=u+1 seq=w，进入LAST-ACK最后确认状态，等待客户端确认 第四次：客户端进程接收到释放报文后，返回ACK=1 ack=w+1 seq=u+1，进入TIME-WAIT时间等待状态，等待的时间就是2MSL，然后才撤销TCB，进入CLOSED状态，结束TCP连接 服务器端进程接收到确认报文后，就进入CLOSED状态，撤销TCB，结束TCP连接 为什么握手是三次，挥手是四次？ 握手时，服务器端进程接收到连接请求后，将确认报文和连接报文都在第二次握手一起发过去；挥手时，服务器端进程接收到释放请求后，先是发送了确认报文，然后再发送释放报文，分两次发送。这就是挥手比握手多一次的原因。 那为什么挥手时要分开发送呢？ 要解答这个问题，就要弄懂服务器进程在分开发送的这个过程中，做了些什么？ 这段时间属于半关闭状态，服务器端进程通知高层的应用进程、还将一些未发送的数据发送给客户端进程。相当于它还有一些事情没完成，需要给它一点时间，但是又需要给客户端先发送确认，免得客户端以为请求失效了 下面这段引用，顺便讲解了发送ack的目的，主要为了检查对方发送的是否和自己发送的一致 第一次握手：主机A发送位码为syn＝1，随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机； 第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1)，syn=1，ack=1，随机产生seq=7654321的包； 第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功。 完成三次握手，主机A与主机B开始传送数据。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/tags/计算机网络/"}]},{"title":"从HTTP状态码301、302到URL劫持","slug":"从HTTP状态码301、302到URL劫持","date":"2018-10-28T13:54:29.000Z","updated":"2018-11-08T07:33:23.592Z","comments":true,"path":"2018/10/28/从HTTP状态码301、302到URL劫持/","link":"","permalink":"https://chenyongyang.github.io/2018/10/28/从HTTP状态码301、302到URL劫持/","excerpt":"","text":"我们都知道HTTP状态码中3xx这系列的都表示重定向，今天这里想说的是301、302这两个状态码 301，表示资源永久性移除到别的地方；302，表示资源暂时性移除到别的地方 共同点是浏览器拿到服务器301或302的状态码之后，都会自动跳转到指定的URL 不同点是遇到301时搜索引擎会抓取新内容，并换上新URL；遇到302时，因为其暂时性，搜索引擎会抓取新内容，保留了原来的URL 当重定向使用的状态码是302暂时性移除时，搜索引擎认为这只是暂时性的，因此就执行的不是那么彻底，所以可能会发生URL劫持，从字面上理解，就是你的网站的URL被偷走了 它的原理是这样的，A网站为自己做了一个重定向，指向B网站，此时当用户输入A网站的URL时，页面将跳转到B网站，用户看到的是B网站的内容；但可能存在一种情况，A网站的URL比较受到搜索引擎的青睐；B网站的URL出于各种原因，不受搜索引擎待见，结果就是用户浏览的是B网站的内容，显示的却是A网站的域名，也就是B网站的URL被A网站劫持了。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/categories/计算机网络/"}],"tags":[]},{"title":"JavaScript变量提升","slug":"JavaScript变量提升","date":"2018-10-28T13:17:42.000Z","updated":"2018-10-28T13:18:09.495Z","comments":true,"path":"2018/10/28/JavaScript变量提升/","link":"","permalink":"https://chenyongyang.github.io/2018/10/28/JavaScript变量提升/","excerpt":"","text":"123456789var a = 0;function func() &#123; console.log(a); // undefined if(a)&#123; var a = 1; console.log(a) // 不会执行此行代码 &#125;&#125;func() 这里主要涉及js变量提升这个知识点。 在js预解析阶段，解析引擎遇到变量声明，会将其提升至作用域的顶部；这就是变量提升；遇到函数声明，会将函数标识符连同函数体一起，提升至作用域顶部，这就是函数声明提升。 回到代码，当预解析func函数时，遇到var a = 1，会将var a;提升至func函数作用域顶部，预解析阶段完毕后，进入执行阶段，console.log(a)因为此时a只是声明了，并没有赋值，因此是undefined，既然a是undefined，那么后面的if判断也就不会执行了。 预解析之后，代码如下：12345678910var a = 0;function func() &#123; var a; console.log(a); // undefined if(a)&#123; a = 1; console.log(a) // 不会执行此行代码 &#125;&#125;func()","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chenyongyang.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chenyongyang.github.io/tags/JavaScript/"}]},{"title":"JavaScript单线程与任务队列","slug":"JavaScript单线程与任务队列","date":"2018-10-28T12:24:34.000Z","updated":"2018-10-28T12:48:07.588Z","comments":true,"path":"2018/10/28/JavaScript单线程与任务队列/","link":"","permalink":"https://chenyongyang.github.io/2018/10/28/JavaScript单线程与任务队列/","excerpt":"","text":"众所周知，JavaScript是一门单线程语言，单线程意味着在同个时间点只能做一件事情，前一个任务执行完了，才执行后面的任务。这些任务都有一个先后顺序，就像我们日常生活中排队一样。JavaScript内部的任务队列正是如我们所描述的，其中排列着等待执行异步任务。 同步任务/异步任务在JavaScript内部，任务可以分为两种：同步任务和异步任务。其中同步任务在主线程上执行，前一个执行完后一个才执行；异步任务在任务队列中等待，只有当主线程任务执行完毕后，才轮到它们运行。 event loop同步任务进入主线程，异步任务进入event table，等到事件执行完毕，回调函数进入event queue；当主线程任务执行完毕，主线程再从event queue中读取事件绑定的函数，将其调入主线程中执行，这个过程是循环重复的，因此也被称为event loop事件循环。 setTimeout/setIntervalsetTimeout原理，并不是说在delay之后就执行回调，而是在这个delay之后，将回调放入消息队列中，等到JS主线程执行完毕后再执行消息队列的程序。这就意味着如果主线程上的代码执行时间很长，定时器的任务会一直等待，因此是没办法保证指定任务一定在delay后执行。即使是setTimeout(fn, 0)，也是将任务放入消息队列后等待执行，0意味着指定某任务在主线程最早得到空闲时执行。setInterval同理，其执行时机依赖于主线程的执行速度。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chenyongyang.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chenyongyang.github.io/tags/JavaScript/"}]},{"title":"JavaScript数组乱序","slug":"JavaScript数组乱序","date":"2018-10-28T08:47:48.000Z","updated":"2018-10-28T09:03:40.693Z","comments":true,"path":"2018/10/28/JavaScript数组乱序/","link":"","permalink":"https://chenyongyang.github.io/2018/10/28/JavaScript数组乱序/","excerpt":"","text":"需求：实现对数组进行乱序，直接上代码123456789101112131415161718// 洗牌算法 Fisher–Yates shufflefunction shuffle(array)&#123; let _array = array.concat() for(let i = 0, rand; i &lt; array.length; i++)&#123; rand = ~~(Math.random() * (i + 1)) // 位运算符，用于取整 let tem = _array[rand]; _array[rand] = _array[i]; _array[i] = tem; &#125; return _array;&#125;// Math.random()取巧，不推荐使用let arr = [1,2,3,4,5,6,7,8]let sign = 1arr.sort((a, b) =&gt; &#123; sign = (Math.random() &gt; 0.5) ? 1 : -1 return (a - b) * sign;&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chenyongyang.github.io/categories/JavaScript/"}],"tags":[]},{"title":"由一道JS题引发的思考","slug":"由一道JS题引发的思考","date":"2018-10-28T05:31:18.000Z","updated":"2018-10-29T03:07:20.693Z","comments":true,"path":"2018/10/28/由一道JS题引发的思考/","link":"","permalink":"https://chenyongyang.github.io/2018/10/28/由一道JS题引发的思考/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233// 例子1for (var i = 0; i &lt; 10; ++i) &#123; setTimeout(function () &#123; console.log(i) // 打印出10个10 &#125;, 0);&#125;for (var i = 0; i &lt; 10; ++i) &#123; (function(i)&#123; setTimeout(function () &#123; console.log(i) // 打印出10个10 &#125;, 0); &#125;(i));&#125;// 例子2function func()&#123; for (var i=0; i&lt;5; i++) &#123; setTimeout(function timer() &#123; console.log(new Date(),i); &#125;, 1000*i ); &#125; console.log(\"end\",new Date(),i);&#125;func();/** 打印结果： end Sun Oct 28 2018 13:36:43 GMT+0800 (中国标准时间) 5 Sun Oct 28 2018 13:36:43 GMT+0800 (中国标准时间) 5 Sun Oct 28 2018 13:36:44 GMT+0800 (中国标准时间) 5 Sun Oct 28 2018 13:36:45 GMT+0800 (中国标准时间) 5 Sun Oct 28 2018 13:36:46 GMT+0800 (中国标准时间) 5 Sun Oct 28 2018 13:36:47 GMT+0800 (中国标准时间) 5/ 原因其实都是类似的，setTimeout是采取异步执行机制，它会等主线程先执行完再执行，而等到主线程执行完，也就是循环已经结束了，此时i的值就是让循环终止的那个临界值，setTimeout拿到这个i值执行相应的回调函数，打印结果 那如果想把每个i的值都打印出来呢？闭包就可以解决这个问题 思路是这样的：循环的时候把每次i值存起来，供异步执行回调时使用 本质就是：虽然程序执行完毕，但它的作用域中的变量不会被销毁，保存在内存中，这样回调就使用 继续思考，变量什么时候被销毁？这就涉及到JS垃圾收集机制 最常用的垃圾收集方式是标记清除。也就是当变量进入执行环境后，就将这个变量标记为进入环境；当变量离开环境时，就将变量标记为离开环境。然后将在环境中的变量、被环境中变量所引用的变量的标记去掉，这样还带有标记的变量就是准备删除的，垃圾收集器就会对它们进行内存清除 换言之，当变量不存在与环境中，或者不被环境中变量所引用时，它就会被清除 回到刚才，我们想要的是循环程序执行完毕，每次循环所创建的环境中的变量i保存下来，那就需要让这个i值被处在环境中的程序所引用，处在环境中的程序也就是这个异步回调，那问题就变成如何让这个异步回调引用每次的i值？ 只需要给每次循环创建一个块级作用域就行了。最简单的就是使用ES6的let关键字，它会创建一个块级作用域12345678910111213141516// 例子1for (let i = 0; i &lt; 10; ++i) &#123; setTimeout(function () &#123; console.log(i) // 依次打印出0 1 2 3 ... &#125;, 0);&#125;// 例子2function func()&#123; for (let i=0; i&lt;5; i++) &#123; setTimeout(function timer() &#123; console.log(new Date(),i); // 这里也可以依次打印出i值 &#125;, 1000*i ); &#125; console.log(\"end\",new Date(),i); // 这里取不到i值，因为此时i是块级作用域，外部程序获取不到&#125;func(); 是否还有其他解决方法呢？当然有，它就是闭包。 闭包是什么？理论上任何函数都是闭包，当在函数内返回函数时，内层闭包就能够获取到外层函数作用域上的变量，当外层函数将内层函数返回，并且内层函数还被外部环境所引用时，我们就实现了外部环境获取函数内部作用域变量。外部环境任何时候都能够引用外层函数内部的变量，也就是外层函数的内部变量被外部环境所引用，这时候即使外层函数执行完销毁了，但是存在于它作用域被引用的变量不会被销毁，会一直保存在内存中。 按照这个思路，我们就可以在异步回调的外层在套上一层函数，将每次循环的i值作为参数传递进去，使得i值作为包围函数作用域的变量，这样异步回调执行时，就可以到包围函数的作用域上获取到i值了，这里涉及到作用域链的知识，接下来会单独写一篇来讲作用域链。 现在的情况就是：异步回调引用了外层函数的i值，因此当外层函数随着循环结束而完毕时，内部的i值仍然可以被异步回调所访问。所以我们的程序就变成下面这样：1234567891011121314151617181920// 例子1for (var i = 0; i &lt; 10; ++i) &#123; (function(i)&#123; setTimeout(function () &#123; console.log(i) // 依次打印出0 1 2 3 ... &#125;, 0); &#125;(i));&#125;// 例子2function func()&#123; for (var i=0; i&lt;5; i++) &#123; (function(i)&#123; setTimeout(function timer() &#123; console.log(new Date(),i); // 这里也可以依次打印出0 1 2 ... &#125;, 1000*i ); &#125;(i)); &#125; console.log(\"end\",new Date(),i); // 这里自然就是循环完毕i的临界值，5&#125;func(); 当然我们还可以将包裹定时器的函数单独抽离出来，然后在循环时调用，这里一方面利用了闭包，另一方面也利用了函数的参数是按值传递而不是按引用传递这个原理，代码如下：123456789101112131415161718192021222324252627282930// 例子1let log = function(i)&#123; setTimeout(()=&gt;&#123; console.log(i) &#125;, 1000)&#125;for (var i = 0; i &lt; 10; ++i) &#123; log(i);&#125;// 例子2let log2 = function(i)&#123; setTimeout(function timer() &#123; console.log(new Date(),i); &#125;, 1000*i );&#125;function func()&#123; for (var i=0; i&lt;5; i++) &#123; log2(i); &#125; console.log(\"end\",new Date(),i);&#125;func();/* end Mon Oct 29 2018 10:39:56 GMT+0800 (中国标准时间) 5 Mon Oct 29 2018 10:39:56 GMT+0800 (中国标准时间) 0 Mon Oct 29 2018 10:39:57 GMT+0800 (中国标准时间) 1 Mon Oct 29 2018 10:39:58 GMT+0800 (中国标准时间) 2 Mon Oct 29 2018 10:39:59 GMT+0800 (中国标准时间) 3 Mon Oct 29 2018 10:40:00 GMT+0800 (中国标准时间) 4*/ 还没结束，从代码的组织上看，我们想要实现的效果是循环打印后，在打印最后的end。可是这里由于end这行代码属于同步任务，所以直接进入主线程中执行，那要如何改成我们想要的结果呢？让所有异步任务执行完毕后，再执行同步任务？ 最简单的办法就是让最后这个同步任务也变成异步任务，让它在i*1000后执行，代码如下：1234567891011121314let log2 = function(i)&#123; setTimeout(function timer() &#123; console.log(new Date(),i); &#125;, 1000 * i);&#125;function func()&#123; for (var i=0; i&lt;5; i++) &#123; log2(i); &#125; setTimeout(() =&gt; &#123; console.log(\"end\",new Date(),i); &#125;, i * 1000);&#125;func(); 但是这种实现不够优雅，其实我们可以用ES6的Promise来解决，代码如下： Promise接收两个匿名函数作为参数，这两个函数都接收一个参数，第一个函数接收的参数resolve表示当异步代码执行完，执行resolve()；第二个函数接收参数reject，表示异步代码执行不成功后，执行reject() 问题是promise中，异步代码的参数如何传递呢？直接在promise外层包一个函数，传递进去就行了123456789101112131415161718192021222324252627282930let tasks = [];let log = (i) =&gt; new Promise((resolve) =&gt; &#123; // promise中只处理异步逻辑，其他无关的逻辑都可以放到外面 // 这个resolve回调应该放在哪里？resolve的位置应该在异步代码中 // 下面这种写法是错的，这一点要注意 // setTimeout(() =&gt; &#123; // console.log(new Date(), i); // &#125;, i * 1000); // resolve(); setTimeout(() =&gt; &#123; console.log(new Date(), i); resolve(); &#125;, i * 1000);&#125;, (reject) =&gt; &#123; reject();&#125;);for(var i = 0; i &lt; 5; i++)&#123; tasks.push(log(i));&#125;Promise.all(tasks).then(() =&gt; &#123; console.log('end', new Date(), i);&#125;)/* Mon Oct 29 2018 11:05:44 GMT+0800 (中国标准时间) 0 Mon Oct 29 2018 11:05:45 GMT+0800 (中国标准时间) 1 Mon Oct 29 2018 11:05:46 GMT+0800 (中国标准时间) 2 Mon Oct 29 2018 11:05:47 GMT+0800 (中国标准时间) 3 Mon Oct 29 2018 11:05:48 GMT+0800 (中国标准时间) 4 end Mon Oct 29 2018 11:05:48 GMT+0800 (中国标准时间) 5*/ Promise方案不仅解决了我们代码执行次序的问题，还让我们的异步代码逻辑变成线性的，更加清晰了 最后，让我们来总结一下。这类题目主要考察我们对于JavaScript的异步执行机制、作用域、闭包的理解与运用，是每个前端开发者应该掌握的基础知识。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chenyongyang.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chenyongyang.github.io/tags/JavaScript/"}]},{"title":"HTTP/2初探","slug":"HTTP-2初探","date":"2018-10-28T02:22:40.000Z","updated":"2018-10-28T02:47:42.946Z","comments":true,"path":"2018/10/28/HTTP-2初探/","link":"","permalink":"https://chenyongyang.github.io/2018/10/28/HTTP-2初探/","excerpt":"","text":"HTTP/2新特性1、单一长连接 客户端向服务器请求资源时，不管请求资源的多少，只会建立一条TCP连接。这样就能够减少TCP握手的次数，提高网络效率 HTTP性能优化的关键在于低延迟，主要就是因为建立TCP连接所消耗的时间太长（TCP慢启动），而单一长连接一定程度上缓解了这个问题 2、多路复用 允许同时通过单一HTTP/2连接发起多重的请求-响应消息 这主要是解决了HTTP/1.1限制了客户端在同一时间请求同一域名的次数，超过次数会被阻塞。多路复用使得在同一时间点上，可以存在多个资源的请求，这些不同的请求存放在每个二进制帧中，以此提高并发量 3、头部压缩，通过HPACK算法压缩头部，减少报文体积 4、服务器推送。在客户端还没向服务器请求某资源时，服务器主动推送某资源给客户端，客户端将这个资源缓存起来，以后要用到时就可以直接走缓存了","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/categories/计算机网络/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://chenyongyang.github.io/tags/HTTP/"}]},{"title":"变量提升和函数提升","slug":"变量提升和函数提升","date":"2018-10-27T13:47:47.000Z","updated":"2018-10-27T13:56:26.500Z","comments":true,"path":"2018/10/27/变量提升和函数提升/","link":"","permalink":"https://chenyongyang.github.io/2018/10/27/变量提升和函数提升/","excerpt":"","text":"写程序时，无论是变量还是函数，我们都是先声明后使用，其实也应该是这样来写。 但有时候我们将两者的顺序颠倒了，先使用了变量或先调用了函数，再来声明变量或函数，发现竟然也没报错。 其实这也是因为JavaScript在执行代码之前，已经将变量声明和函数声明都放到内存中了，到了执行阶段程序就可以从内存中读取变量和函数的定义了。 123num = 6;num + 7;var num; // num为13 12345func(\"hello\");function func(str) &#123; console.log(str); // 输出hello&#125; 需要注意的一点是：JavaScript只提升声明，不提升初始化。123var x = 1; console.log(x, y); // 这里y是undefined，因为下面的y不仅仅是声明，是声明并初始化var y = 2;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chenyongyang.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chenyongyang.github.io/tags/JavaScript/"}]},{"title":"Cookie与Session","slug":"Cookie与Session","date":"2018-10-27T12:29:08.000Z","updated":"2019-03-26T12:27:59.641Z","comments":true,"path":"2018/10/27/Cookie与Session/","link":"","permalink":"https://chenyongyang.github.io/2018/10/27/Cookie与Session/","excerpt":"","text":"Cookie和Session都被用于会话跟踪，它们都是为了解决HTTP无状态这一个特性，不同点在于Cookie是在客户端保存状态；而Session是在服务器端保存状态 如果cookie不设置过期时间，则默认为会话Cookie，这种Cookie存储在内存中，随浏览器关闭而清除；如果设置了过期时间，则cookie就存储在客户端硬盘中 Session保存在服务器端。通常浏览器第一次访问某页面，发送给服务器的请求中自然就没有携带sessionId，那么当服务器就会生成一个sessionId，并将其放在响应头中，以cookie的形式返回给客户端，客户端拿到这个ID保存起来，下一次访问时就可以将这个ID发送给服务器端，服务器就可以根据这个ID到保存session的地方寻找对应的数据，将数据返回给客户端 Cookie是实现Session的一种方式，这个sessionId就存储在cookie中 如果用户禁用了cookie，服务器端如何跟踪用户呢？利用URL重写，浏览器将sessionId作为get请求的参数发送给服务器端，这样服务器照样可以找到session的数据 区别 cookie保存在客户端，session保存在服务器端 session存储量比cookie大 用户可以看到cookie，但是看不到session session依赖sessionId，sessionId存储在cookie中，从这个角度看，cookie是session的一种实现形式","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://chenyongyang.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://chenyongyang.github.io/tags/HTTP/"}]},{"title":"作用域链与变量解析","slug":"作用域链与变量解析","date":"2018-10-27T11:01:10.000Z","updated":"2018-10-27T11:02:54.611Z","comments":true,"path":"2018/10/27/作用域链与变量解析/","link":"","permalink":"https://chenyongyang.github.io/2018/10/27/作用域链与变量解析/","excerpt":"","text":"概念作用域链是一个对象列表或者链表，这组对象定义了这段代码作用域内的变量 如何产生当代码在一个环境中执行，就会创建这个变量对象的作用域链 变量解析过程变量解析时，首先从作用域链的前端开始，作用域链的前端就是当前执行代码所在环境的变量对象，如果找不到就往后回溯，到上一级执行环境的变量对象中找，如果在链的末端还找不到，则抛出一个引用错误异常","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chenyongyang.github.io/categories/JavaScript/"}],"tags":[{"name":"作用域链","slug":"作用域链","permalink":"https://chenyongyang.github.io/tags/作用域链/"}]},{"title":"探究vue双向绑定原理","slug":"探究vue双向绑定原理","date":"2018-10-27T06:46:02.000Z","updated":"2018-11-11T03:18:27.943Z","comments":true,"path":"2018/10/27/探究vue双向绑定原理/","link":"","permalink":"https://chenyongyang.github.io/2018/10/27/探究vue双向绑定原理/","excerpt":"","text":"双向绑定就是数据和视图的双向绑定，数据变化更新视图，视图变化更新数据 视图变化更新数据，我们可以通过监听页面上的DOM事件，从而去修改数据 数据变化更新视图，首先进行数据劫持，使得我们能够感知到数据的变化；感知到数据的变化后，通知它的订阅者，订阅者执行更新函数，进而更新视图 订阅者是如何形成的呢？它是通过Compile解析器来实现的，解析器扫描每个节点，将相关指令初始化为一个订阅者Watcher，当然解析器在这个过程中还进行了其他操作，例如更换模板数据、绑定函数等 Observer观察者劫持data对象所有数据，监听数据变动；Compile解析器对每个节点进行解析，提取模板中的各种指令，获取数据对象，将数据更换到模板中，对视图进行初始化渲染，同时将更新视图的函数传递给订阅者；因为一个数据可能不止被用了一次，也就是它可能有多个订阅者，因此我们需要一个数据结构来存储订阅者，它就是Dep，Dep中存储着数据依赖项也就是订阅者，这个过程是在劫持数据对象时get方法中进行的；一旦数据有变动，就进入了set方法，观察者就通知Dep，Dep就通知所有的订阅者，订阅者接收到数据变动后，调用更新函数去更新视图，这就是数据变化更新视图的背后的原理。","categories":[{"name":"vue.js","slug":"vue-js","permalink":"https://chenyongyang.github.io/categories/vue-js/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://chenyongyang.github.io/tags/vue-js/"}]},{"title":"HTTP权威指南学习笔记——HTTPS","slug":"HTTP权威指南学习笔记——HTTPS","date":"2018-10-27T06:10:17.000Z","updated":"2018-10-28T03:16:18.146Z","comments":true,"path":"2018/10/27/HTTP权威指南学习笔记——HTTPS/","link":"","permalink":"https://chenyongyang.github.io/2018/10/27/HTTP权威指南学习笔记——HTTPS/","excerpt":"","text":"HTTPS概述HTTPS的主要原理是，它在将HTTP报文发送给TCP之前，先发给一个安全层，对报文进行加密处理。现在HTTP的安全层是通过SSL和TLS来实现的，一般都统称为SSL。 HTTPS为什么会出现就是因为HTTP存在着以下这些问题：1、被监听，因为HTTP传输的数据是明文，如果中途被劫持了，类似于密码之类的信息就不安全；对此HTTPS对数据进行加密处理 2、被伪装，客户端请求到的数据并一定来源于合法的地址；对此HTTPS采用了数字证书 3、被篡改，HTTP在传输过程中，数据可以随时被改动；对此HTTPS对数据进行摘要，可以感知数据变动 正是出于这些不安全因素，HTTPS应运而生 HTTPS方案一般通过URL来告知Web服务器执行HTTP安全协议版本，也就是URL方案的前缀为http或https 如果URL走的是HTTPS，客户端会开启443默认端口来连接服务器，进行握手过程，同服务器交换SSL安全参数，附上加密的HTTP命令 安全传输建立流程客户端发送一个HTTPS方案的请求之后，客户端会通过443端口与服务器建立连接，TCP连接建立以后，客户端和服务器会初始化SSL层，沟通加密参数，并交换密钥，握手完成后，SSL初始化完成，客户端发送请求报文给安全层。 如何保障安全对称加密、非对称加密、数字证书 加密的HTTPS事务流程 建立到服务器443端口的TCP连接 双方进行SSL安全参数握手 在SSL发送HTTP请求，在TCP发送已经加密的请求 在SSL发送HTTP响应，在TCP发送已经加密的响应 SSL关闭通知 TCP关闭连接 SSL安全参数握手流程 客户端向服务器发送可供选择的密码，并请求证书 服务器发送选中密码和证书 客户端发送保密信息，双方生成密钥 双方互相告知，开始加密过程 站点证书的有效性校验 日期检测 签名颁发者可信度检测 签名检测 站点身份检测 SSL握手简化版流程客户端发送HTTPS请求给服务器端 服务器端选择合适的加密协议后，返回数字证书及公钥 客户端验证数字证书是否合格，如果不合格则提示证书有问题；如果合格；则随机生成对称密钥，使用数字证书上的公钥对其进行加密，发送给服务器端 服务器端使用私钥对证书进行解密，得到客户端的对称密钥，对要返回的内容用对称私钥加密，发送给客户端 客户端通过对称私钥解密，得到数据，握手结束","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/tags/计算机网络/"}]},{"title":"前端性能优化初探","slug":"前端性能优化初探","date":"2018-10-27T05:48:03.000Z","updated":"2018-11-08T07:32:21.532Z","comments":true,"path":"2018/10/27/前端性能优化初探/","link":"","permalink":"https://chenyongyang.github.io/2018/10/27/前端性能优化初探/","excerpt":"","text":"前端性能优化可以从很多方面入手，其中网络请求层面是一个重点内容，而这方面一般有两个思路，1、减少网络请求；2、减小网络请求的体积 减少网络请求体积的一般做法有：合并请求资源，制作雪碧图，压缩请求等 js执行层面之所以耗费资源主要是源于内存泄漏，所以我们经常说要及时清空没有被使用的引用 页面渲染层面，一般强调减少DOM操作，这也是虚拟DOM产生的背景","categories":[{"name":"性能优化","slug":"性能优化","permalink":"https://chenyongyang.github.io/categories/性能优化/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://chenyongyang.github.io/tags/性能优化/"}]},{"title":"GET和POST的区别","slug":"GET和POST的区别","date":"2018-10-27T02:31:47.000Z","updated":"2018-10-27T07:26:17.978Z","comments":true,"path":"2018/10/27/GET和POST的区别/","link":"","permalink":"https://chenyongyang.github.io/2018/10/27/GET和POST的区别/","excerpt":"","text":"要讲清楚这两个请求方法的区别，其实可以从RTC（一个互联网规范）对HTTP协议描述的特性出发 HTTP协议对请求方法规定了这几个特性：安全性、幂等性、可缓存性 首先是安全性。如果一个方法的语义是只读，那它就是安全的，也就是意味着它不会对服务器的资源作任何的改动；它是无害的。这些都是属于规范层面，但在实际操纵中的实现不一定是安全的，例如用GET方法修改用户信息 其次是幂等性。概念是同个方法执行多次和执行一次效果是一样的。GET方法是幂等的，POST方法不幂等。原因是可以从为什么要引入幂等性思考？主要是为了处理同一个请求重复发送的问题。例如用户填写了表单，表单数据用POST提交到服务器，此时用户不小心使得浏览器后退或者刷新了页面，浏览器就会提示用户数据会丢失，保证POST过去的都不是重复的 最后是可缓存性。GET方法可以缓存，POST方法不可缓存，这也是处于语义上的需要 还要其他一些区别：GET有长度限制，这和GET是通过URL参数传递信息有关；POST长度不限； 总结：GET方法是获取指定资源，它是安全的、幂等的、可以缓存的；POST方法根据报文主体的payload对指定资源作处理，它是不安全、不幂等 参考链接：MDN上关于HTTP的阐述","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/categories/计算机网络/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://chenyongyang.github.io/tags/HTTP/"}]},{"title":"Vue.js响应式原理","slug":"Vue-js响应式原理","date":"2018-10-26T12:17:02.000Z","updated":"2018-10-27T07:26:02.611Z","comments":true,"path":"2018/10/26/Vue-js响应式原理/","link":"","permalink":"https://chenyongyang.github.io/2018/10/26/Vue-js响应式原理/","excerpt":"","text":"主要由三部分组成Observer Compiler Watcher Observer监听数据变化，使得当数据变化时，我们有能力去执行一些操作 Compiler解析模板，将数据结合模板渲染到页面上 Watcher将两者结合起来，当挂载组件或初始化计算属性时，都会去实例化Watcher，将target传递给Observer，执行数据的getter方法，getter方法中取到target并收集到Dep中，这样就完成了依赖收集；当数据发生变化时，会调用dep.notify方法，通知所有的监听者Watcher，Watcher再调用参数中的回调函数update，更新视图","categories":[{"name":"vue.js","slug":"vue-js","permalink":"https://chenyongyang.github.io/categories/vue-js/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://chenyongyang.github.io/tags/vue-js/"}]},{"title":"Cookie、localStorage、sessionStorage三者的区别","slug":"Cookie、localStorage、sessionStorage三者的区别","date":"2018-10-25T13:20:04.000Z","updated":"2018-10-27T12:27:52.816Z","comments":true,"path":"2018/10/25/Cookie、localStorage、sessionStorage三者的区别/","link":"","permalink":"https://chenyongyang.github.io/2018/10/25/Cookie、localStorage、sessionStorage三者的区别/","excerpt":"","text":"共同点都是客户端存储方案 不同点： Cookie在浏览器和服务器之间传输，附加于HTTP报文中；localStorage、sessionStorage只是活动于浏览器端，不需要和服务器通信 Cookie有path字段，可以规范Cookie的存储路径；localStorage、sessionStorage没有 存储大小方面，Cookie只有4KB；，这是由于它是存在于HTTP报文中，数据量自然不能过大；localStorage、sessionStorage能够存储5MB以上 数据的生命周期方面，Cookie如果是存在于内存中，则在关闭浏览器后便被释放，如果存在于硬盘中，有个过期时间或可手动清除；localStorage如果不手动清除，将会一直存在；sessionStorage在当前浏览器关闭之前有效 作用域方面，Cookie、localStorage只要是同源窗口就能生效（即使是不同浏览器）sessionStorage在不同的浏览器是不同的（即使是同个网站） localStorage、sessionStorage API提供了可监听的事件，可以在数据变动是执行相应动作 应用场景方面：Cookie现在一般用于用户登录信息存储；localStorage、sessionStorage一般用于购物车、存储较大的数据量；表单信息；网站访客统计等；localStorage可做一些数据持久化工作，减少数据库的访问量","categories":[{"name":"前端存储","slug":"前端存储","permalink":"https://chenyongyang.github.io/categories/前端存储/"}],"tags":[{"name":"前端存储","slug":"前端存储","permalink":"https://chenyongyang.github.io/tags/前端存储/"}]},{"title":"一起来学Cookie","slug":"一起来学Cookie","date":"2018-10-25T12:40:39.000Z","updated":"2018-10-27T12:28:11.247Z","comments":true,"path":"2018/10/25/一起来学Cookie/","link":"","permalink":"https://chenyongyang.github.io/2018/10/25/一起来学Cookie/","excerpt":"","text":"是什么 Cookie，也叫作小型文本文件，本质上是存储在客户端的数据，网站能够通过这些数据来辨别用户身份 按照数据存储在客户端不同的位置，可以将Cookie分为内存Cookie、硬盘Cookie 内存Cookie和浏览器挂钩，当关闭了浏览器，其占用的内存也就被释放，内存Cookie自然就被清除；也被称为非持久Cookie 硬盘Cookie，顾名思义就是存储在硬盘中的数据，一般都有个过期时间，用户也可以手动清除；也被称为持久Cookie 应用场景 购物车，当用户选中一个商品到购物车，服务器端返回浏览器页面的同时，也会将选中的商品的信息放入Cookie一起发送过去，当用户再选中商品时，浏览器在发送请求上会带上之前的Cookie，服务器接收到后，就能够将新的商品添加到上一次的商品后一起返回响应，这实际上解决了HTTP无状态所带来的客户操作状态无法保存的限制。 网站登录。第一次登录时如果勾选了自动登录，那么服务器端接收到用户的表单数据，进行一系列验证，返回响应时会携带一个加密的Cookie，这段Cookie将存储在用户硬盘中，当第二次登录时，浏览器就可以发送这段Cookie给服务器，服务器验证通过就可以直接登录了。 不足 Cookie在服务器端和客户端之间的传输，总是附加在HTTP报文中，增加了流量 在HTTP中，Cookie是明文的，不安全；可以考虑HTTPS 存储大小只有4KB，不适合复杂数据存储","categories":[{"name":"前端存储","slug":"前端存储","permalink":"https://chenyongyang.github.io/categories/前端存储/"}],"tags":[{"name":"前端存储","slug":"前端存储","permalink":"https://chenyongyang.github.io/tags/前端存储/"}]},{"title":"前端缓存","slug":"前端缓存","date":"2018-10-21T09:14:21.000Z","updated":"2018-11-04T02:26:16.438Z","comments":true,"path":"2018/10/21/前端缓存/","link":"","permalink":"https://chenyongyang.github.io/2018/10/21/前端缓存/","excerpt":"什么是前端缓存？ 浏览器将对于已经请求过的资源缓存起来，等到下一次请求同样资源时，浏览器直接将缓存副本返回响应，不必向浏览器发送请求 前端缓存的好处 缩短网络请求的距离，减少延迟，加快网页打开速度，性能优化 资源重复利用，减少带宽，降低服务器压力 如何实现前端缓存？","text":"什么是前端缓存？ 浏览器将对于已经请求过的资源缓存起来，等到下一次请求同样资源时，浏览器直接将缓存副本返回响应，不必向浏览器发送请求 前端缓存的好处 缩短网络请求的距离，减少延迟，加快网页打开速度，性能优化 资源重复利用，减少带宽，降低服务器压力 如何实现前端缓存？ 首先来了解与缓存有关的HTTP报文字段 通用首部字段 Pragma 定义在Meta标签，通常指为no-cache，禁用缓存 1&lt;meta http-equiv=\"Pragma\" content=\"no-cache\"&gt; 浏览器设置作用不大，服务器端设置为主 仅IE能识别 与禁用缓存相对的是启用缓存，Expires出现了 Cache-Control 解决服务器和浏览器时间标准不一致 定义缓存过期时间，与Pragma Expires相比，优先级最高 如果资源缓存过期，但资源还是一样，在资源较大的情况下，是不应该又去服务器请求一遍的 我们需要让服务器知道前端缓存的资源是否跟自己一致，如果一致就让浏览器直接用缓存，这时候Last-Modified出现了 请求首部字段 If-Match 浏览器通过PUT方法时，通过这个字段传递ETag If-None-Match 浏览器告诉服务器如果ETag没匹配上，返回新资源，否则返回304 ETag就存储在这个字段中 If-Modified-Since 浏览器通过这个字段告诉服务器如果最后修改时间一致，则返回304 Last-Modified就存储在这个字段中 If-Unmodified-Since 浏览器通过这个字段告诉服务器如果最后修改时间不一致，则返回412 响应首部字段 ETag 服务器返回资源的同时，将ETag一并返回，浏览器接收到后为资源打上这个标记，下一次请求时，将这个值发给服务器，服务器和之前的作对比，如果一致，返回304；否则返回新资源 通过对资源进行某个算法，生成一个类似md5的唯一标识符，而不仅仅靠修改时间 如果和Last-Modified同时使用，需要两者都返回304，才会走缓存，否则返回新资源 实体首部字段 Expires 服务器返回的资源缓存过期时间（GMT 格林尼治时间），时间点是服务器的时间 在浏览器，IE下可以这样设置，这种做法也仅限IE 1&lt;meta http-equiv=\"expires\" content=\"mon, 18 apr 2016 14:30:00 GMT\"&gt; 得在服务器端报头返回该字段，缓存过期时间才能正确生效 同时设置，Pragma优先级更高 但如果服务器和浏览器的时间标准不一致，这个设置也就失效了，因此Cache-Control出现了 Last-Modified 服务器端资源的最后修改时间 服务器向浏览器返回资源的同时，会携带一个Last-Modified，它的值为格林尼治时间；浏览器接收到响应后，会给资源标记上这个值，等到下一次向服务器请求时，将这个值一并发过去，服务器就会对比浏览器发过来的值和之前发给浏览器的值，如果两个最后修改的时间一致，则返回304，让浏览器直接读取缓存资源 不足：当服务器资源被修改，但实际内容没变，这个时候还是会将资源返回，这时候ETag出现了 强缓存不会发送请求到服务器，协商缓存会发送请求到服务器，通过请求首部字段验证 强缓存：Pragma / Expires / Cache-Control 协商缓存：Last-Modified/If-Modified-Since、ETag/If-None-Match If-Modified-Since/Last-ModifiedIf-Modified-Since存在于请求头中，当它被发送到服务器时，服务器会将它和Last-Modified的值作对比，如果两者日期一致，则告知浏览器可以使用本地缓存 If-None-Match/EtagIf-None-Match存储一个字符串，当它被发送到服务器时，服务器会将它和Etag的值作对比，如果匹配上了，则告知浏览器可以使用本地缓存 流程是这样的：浏览器第一次请求页面，服务器在返回结果的同时，也将Last-Modified和Etag值传递过去；浏览器接收到响应，将这两个值都缓存起来；等到下一次请求同个页面，这两个值会将这两个值分别放入If-Modified-Since/If-None-Match并发送到服务器，服务器拿这两个值和之前的作对比，如果其中一个命中，就返回304和空响应体，这就是协商缓存的过程 具体应用 使用Expires来兼容旧浏览器 使用Cache-Control来精准控制缓存 使用ETag和Last-Modified来进一步复用 一般缓存时间为60s 对于静态资源（如图片）则会久一点 浏览器可以在图片的URL后设置max-age 浏览器可以对静态资源以版本形式发布，加上hash值，以确保能及时从服务器获取最新资源","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/tags/计算机网络/"}]},{"title":"动手实现Vue.js响应式","slug":"动手实现Vue-js响应式","date":"2018-10-21T05:43:14.000Z","updated":"2018-11-04T02:26:29.096Z","comments":true,"path":"2018/10/21/动手实现Vue-js响应式/","link":"","permalink":"https://chenyongyang.github.io/2018/10/21/动手实现Vue-js响应式/","excerpt":"想要实现这样的功能：1234567let price = 5let quantity = 2let total = price * quantityconsole.log(total) // 10price = 10 // 修改dataconsole.log(total) // 如果是响应式，就应该是20 现在就是来实现这样的响应式功能 既然要实现改变单价或质量，总价格就会更新，本质上就是当数据改变时，再次执行计价 因此我们应该把这个计价封装成一个函数，以便之后调用123target = () =&gt; &#123; total = price * quantity&#125;","text":"想要实现这样的功能：1234567let price = 5let quantity = 2let total = price * quantityconsole.log(total) // 10price = 10 // 修改dataconsole.log(total) // 如果是响应式，就应该是20 现在就是来实现这样的响应式功能 既然要实现改变单价或质量，总价格就会更新，本质上就是当数据改变时，再次执行计价 因此我们应该把这个计价封装成一个函数，以便之后调用123target = () =&gt; &#123; total = price * quantity&#125; 可能有多个对数据的处理函数，因此我们定义一个数组来存储12storge = []storge.push(target) 以后我们想要调用计较函数，就可以这样1storge.forEach(run =&gt; run()) 完整代码如下1234567891011121314151617181920212223let price = 5let quantity = 2let total = 0let target = nulllet storge = [] // 存储targetfunction recode()&#123; // 将target记录起来 storge.push(target)&#125;function replay()&#123; storge.forEach(run =&gt; run())&#125;target = () =&gt; &#123; total = price * quantity&#125;recode()target()price = 10console.log(total) // 10replay()console.log(total) // 20 我们现在有了一个target，同时将target存储在storge列表中，通过replay方法通知target。这一切都可以封装成一个类，这是依赖类就出现了。12345678910111213141516171819202122232425262728class Dep&#123; constructor()&#123; this.subscribers = []; // 代替storge &#125; depend()&#123; // 代替recode if(target &amp;&amp; !this.subscribers.includes(target))&#123; this.subscribers.push(target) &#125; &#125; notify()&#123; // 代替replay this.subscribers.forEach(sub =&gt; sub()) // run target or observer &#125;&#125;let dep = new Dep()let price = 5let quantity = 2let total = 0let target = () =&gt; &#123; total = price * quantity&#125;dep.depend() // 添加依赖（这个依赖指的是target）target()console.log(total) // 10price = 10console.log(total) // 10dep.notify()console.log(total) // 20 现在还有一点不足：还需要去定义和调用target；我们完全可以把target的定义和调用都封装起来 我们要封装的就是创建监听更新的匿名函数的行为；这时候可以引进Watcher观察者函数123456function watcher(func)&#123; target = func; dep.depend(); target(); target = null&#125; 这样我们就把创建监听更新的匿名函数、依赖的收集都封装到一起。 将代码整合一下1234567891011121314151617181920212223242526272829303132class Dep&#123; constructor(func)&#123; this.subscribers = []; // 代替storge this.target = null; this.watcher(func); &#125; depend()&#123; // 代替recode if(this.target &amp;&amp; !this.subscribers.includes(this.target))&#123; this.subscribers.push(this.target) &#125; &#125; notify()&#123; // 代替replay this.subscribers.forEach(sub =&gt; sub()) // run target or observer &#125; watcher(func)&#123; this.target = func this.depend() this.target() this.target = null &#125;&#125;let price = 5;let quantity = 2let total = 0let dep = new Dep(()=&gt;&#123;total = price * quantity&#125;);price = 10 // data数据修改console.log(total) // 10dep.notify() // dep通知target更新console.log(total) // 20 到此为止，当我们修改数据一修改，只要通知存储在依赖类实例的target，即可实现依赖数据的修改 但我们还需要手动执行dep.notify，我们希望数据一修改就自动执行dep.notify，而且应该是每个数据都有这个能力 我们希望当访问数据对象属性时，将target所指向的更新函数添加到subscribers中；当修改数据对象属性时，通知其依赖数据 我们需要一些方式来挂钩数据属性，使得当访问它时，能够将target推送到subscribers数组中；当它被修改时，运行存储在subscribers数组中的函数 这时候就需要Object.defineProperty() 最终代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142let data = &#123; price: 5, quantity: 2&#125;let target = nullclass Dep&#123; constructor()&#123; this.subscribers = [] &#125; depend()&#123; if(target &amp;&amp; !this.subscribers.includes(target))&#123; this.subscribers.push(target) &#125; &#125; notify()&#123; this.subscribers.forEach(sub=&gt;sub()) &#125;&#125;Object.keys(data).forEach(key =&gt; &#123; let value = data[key] let dep = new Dep() Object.defineProperty(data, key, &#123; get()&#123; dep.depend() return value; &#125;, set(newValue)&#123; value = newValue dep.notify() &#125; &#125;)&#125;)function watcher(func)&#123; target = func target() target = null&#125;watcher(() =&gt; &#123; data.total = data.price * data.quantity&#125;) 至此，我们实现了price quantity的响应式，一旦数据更改，依赖的数据也随之更改","categories":[{"name":"vue.js","slug":"vue-js","permalink":"https://chenyongyang.github.io/categories/vue-js/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://chenyongyang.github.io/tags/vue-js/"}]},{"title":"笔记","slug":"笔记","date":"2018-10-05T07:06:38.000Z","updated":"2019-03-16T08:41:22.337Z","comments":true,"path":"2018/10/05/笔记/","link":"","permalink":"https://chenyongyang.github.io/2018/10/05/笔记/","excerpt":"","text":"css水平居中 css3动画 @keyframes promise实现 改变this指向： 箭头函数 函数内部使用_this=this 使用call apply bind new关键字 apply接收的是数组，call接收参数列表 js继承方式 借用构造函数 组合继承 原型继承，后来别Object.create()规范化了 寄生 寄生组合 箭头函数 this指向问题 不可以当做构造函数，无法使用new 不存在arguments对象，可用rest代替 Promise 有异步操作时，就要用到promise来封装 reject方法等同于抛出错误 已经resolve了，就不能抛出错误了 then方法中的第二个参数定义的是reject状态的回调函数，但是一般不这么做，一般是将promise所产生的错误统一由catch方法来捕获，因为promise的错误具有冒泡性质，用catch可以捕获then方法执行中的错误，类似于try…catch… finally方法意味着无论如何，最后都会执行它，比如关掉服务器 将多个promise实例，包装成一个新的promise实例 resolve方法将现有对象转为promise对象 reject类似于throw，是用来抛出错误的；catch是用来处理错误 如果在 then 的第一个函数里抛出了异常，后面的 catch 能捕获到，而第二个函数捕获不到 link和@import的区别 link不仅可以引入css，还支持rss等其他事务；@import只支持css link在页面加载时同步引入css，@import需要等到页面加载完毕后才引入 事件绑定 行内绑定 动态绑定 事件监听 jq事件绑定 bind,one,unbind async await navigator.userAgent获取浏览器版本 serviceworker 消息推送 离线缓存 xss 跨站脚本攻击csrf 跨站请求伪造","categories":[],"tags":[]},{"title":"小知识点总结","slug":"小知识点总结","date":"2018-09-28T12:52:21.000Z","updated":"2018-10-28T12:53:26.606Z","comments":true,"path":"2018/09/28/小知识点总结/","link":"","permalink":"https://chenyongyang.github.io/2018/09/28/小知识点总结/","excerpt":"","text":"DOCTYPE 告知浏览器按照哪个版本的Html进行编写命令，什么类型的文档定义来解析文档 div不换行 display: inline-block float flex position: absolute","categories":[],"tags":[]},{"title":"学习Vue.js源码的前置知识","slug":"学习Vue-js源码的前置知识","date":"2018-07-21T04:00:00.000Z","updated":"2018-11-04T02:26:44.453Z","comments":true,"path":"2018/07/21/学习Vue-js源码的前置知识/","link":"","permalink":"https://chenyongyang.github.io/2018/07/21/学习Vue-js源码的前置知识/","excerpt":"","text":"前置知识 Flow JavaScript静态类型检测，类似于typescript object.defineProperty proxy get set","categories":[{"name":"vue.js","slug":"vue-js","permalink":"https://chenyongyang.github.io/categories/vue-js/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://chenyongyang.github.io/tags/vue-js/"}]},{"title":"Hexo基本操作","slug":"Hexo基本操作","date":"2017-10-30T00:00:00.000Z","updated":"2018-11-04T02:26:04.126Z","comments":true,"path":"2017/10/30/Hexo基本操作/","link":"","permalink":"https://chenyongyang.github.io/2017/10/30/Hexo基本操作/","excerpt":"","text":"写文章 hexo new 文章标题 预览效果 hexo s 开启hexo server 在localhost调试 发布到github page hexo clean 清除历史数据 hexo d -g 先生成再发布","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://chenyongyang.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://chenyongyang.github.io/tags/Hexo/"}]}]}