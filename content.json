{"meta":{"title":"我的博客","subtitle":"每天进步一点点","description":null,"author":"陈泳仰","url":"https://chenyongyang.github.io"},"pages":[{"title":"分类","date":"2018-10-27T07:18:24.000Z","updated":"2018-10-27T07:18:55.864Z","comments":true,"path":"categories/index.html","permalink":"https://chenyongyang.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-10-27T07:23:35.000Z","updated":"2018-10-27T07:23:55.780Z","comments":true,"path":"tags/index.html","permalink":"https://chenyongyang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"计算机网络——TCP连接","slug":"计算机网络——TCP连接","date":"2018-10-30T13:57:16.000Z","updated":"2018-10-30T13:58:07.765Z","comments":true,"path":"2018/10/30/计算机网络——TCP连接/","link":"","permalink":"https://chenyongyang.github.io/2018/10/30/计算机网络——TCP连接/","excerpt":"","text":"今天来一起来弄懂TCP连接这一块知识点。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/tags/计算机网络/"}]},{"title":"HTTP状态码301和302及URL劫持","slug":"HTTP状态码301和302及URL劫持","date":"2018-10-28T13:54:29.000Z","updated":"2018-10-28T14:15:59.794Z","comments":true,"path":"2018/10/28/HTTP状态码301和302及URL劫持/","link":"","permalink":"https://chenyongyang.github.io/2018/10/28/HTTP状态码301和302及URL劫持/","excerpt":"","text":"我们都知道HTTP状态码中3xx这系列的都表示重定向，今天这里想说的是301、302这两个状态码 301，表示资源永久性移除到别的地方；302，表示资源暂时性移除到别的地方 共同点是浏览器拿到服务器301或302的状态码之后，都会自动跳转到指定的URL 不同点是遇到301时搜索引擎会抓取新内容，并换上新URL；遇到302时，因为其暂时性，搜索引擎会抓取新内容，保留了原来的URL 当重定向使用的状态码是302暂时性移除时，搜索引擎认为这只是暂时性的，因此就执行的不是那么彻底，所以可能会发生URL劫持，从字面上理解，就是你的网站的URL被偷走了 它的原理是这样的，A网站为自己做了一个重定向，指向B网站，此时当用户输入A网站的URL时，页面将跳转到B网站，用户看到的是B网站的内容；但可能存在一种情况，A网站的URL比较受到搜索引擎的青睐；B网站的URL出于各种原因，不受搜索引擎待见，结果就是用户浏览的是B网站的内容，显示的却是A网站的域名，也就是B网站的URL被A网站劫持了。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/categories/计算机网络/"}],"tags":[]},{"title":"JavaScript变量提升","slug":"JavaScript变量提升","date":"2018-10-28T13:17:42.000Z","updated":"2018-10-28T13:18:09.495Z","comments":true,"path":"2018/10/28/JavaScript变量提升/","link":"","permalink":"https://chenyongyang.github.io/2018/10/28/JavaScript变量提升/","excerpt":"","text":"123456789var a = 0;function func() &#123; console.log(a); // undefined if(a)&#123; var a = 1; console.log(a) // 不会执行此行代码 &#125;&#125;func() 这里主要涉及js变量提升这个知识点。 在js预解析阶段，解析引擎遇到变量声明，会将其提升至作用域的顶部；这就是变量提升；遇到函数声明，会将函数标识符连同函数体一起，提升至作用域顶部，这就是函数声明提升。 回到代码，当预解析func函数时，遇到var a = 1，会将var a;提升至func函数作用域顶部，预解析阶段完毕后，进入执行阶段，console.log(a)因为此时a只是声明了，并没有赋值，因此是undefined，既然a是undefined，那么后面的if判断也就不会执行了。 预解析之后，代码如下：12345678910var a = 0;function func() &#123; var a; console.log(a); // undefined if(a)&#123; a = 1; console.log(a) // 不会执行此行代码 &#125;&#125;func()","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chenyongyang.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chenyongyang.github.io/tags/JavaScript/"}]},{"title":"JavaScript单线程与任务队列","slug":"JavaScript单线程与任务队列","date":"2018-10-28T12:24:34.000Z","updated":"2018-10-28T12:48:07.588Z","comments":true,"path":"2018/10/28/JavaScript单线程与任务队列/","link":"","permalink":"https://chenyongyang.github.io/2018/10/28/JavaScript单线程与任务队列/","excerpt":"","text":"众所周知，JavaScript是一门单线程语言，单线程意味着在同个时间点只能做一件事情，前一个任务执行完了，才执行后面的任务。这些任务都有一个先后顺序，就像我们日常生活中排队一样。JavaScript内部的任务队列正是如我们所描述的，其中排列着等待执行异步任务。 同步任务/异步任务在JavaScript内部，任务可以分为两种：同步任务和异步任务。其中同步任务在主线程上执行，前一个执行完后一个才执行；异步任务在任务队列中等待，只有当主线程任务执行完毕后，才轮到它们运行。 event loop同步任务进入主线程，异步任务进入event table，等到事件执行完毕，回调函数进入event queue；当主线程任务执行完毕，主线程再从event queue中读取事件绑定的函数，将其调入主线程中执行，这个过程是循环重复的，因此也被称为event loop事件循环。 setTimeout/setIntervalsetTimeout原理，并不是说在delay之后就执行回调，而是在这个delay之后，将回调放入消息队列中，等到JS主线程执行完毕后再执行消息队列的程序。这就意味着如果主线程上的代码执行时间很长，定时器的任务会一直等待，因此是没办法保证指定任务一定在delay后执行。即使是setTimeout(fn, 0)，也是将任务放入消息队列后等待执行，0意味着指定某任务在主线程最早得到空闲时执行。setInterval同理，其执行时机依赖于主线程的执行速度。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chenyongyang.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chenyongyang.github.io/tags/JavaScript/"}]},{"title":"JavaScript数组乱序","slug":"JavaScript数组乱序","date":"2018-10-28T08:47:48.000Z","updated":"2018-10-28T09:03:40.693Z","comments":true,"path":"2018/10/28/JavaScript数组乱序/","link":"","permalink":"https://chenyongyang.github.io/2018/10/28/JavaScript数组乱序/","excerpt":"","text":"需求：实现对数组进行乱序，直接上代码123456789101112131415161718// 洗牌算法 Fisher–Yates shufflefunction shuffle(array)&#123; let _array = array.concat() for(let i = 0, rand; i &lt; array.length; i++)&#123; rand = ~~(Math.random() * (i + 1)) // 位运算符，用于取整 let tem = _array[rand]; _array[rand] = _array[i]; _array[i] = tem; &#125; return _array;&#125;// Math.random()取巧，不推荐使用let arr = [1,2,3,4,5,6,7,8]let sign = 1arr.sort((a, b) =&gt; &#123; sign = (Math.random() &gt; 0.5) ? 1 : -1 return (a - b) * sign;&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chenyongyang.github.io/categories/JavaScript/"}],"tags":[]},{"title":"由一道JS题引发的思考","slug":"由一道JS题引发的思考","date":"2018-10-28T05:31:18.000Z","updated":"2018-10-29T03:07:20.693Z","comments":true,"path":"2018/10/28/由一道JS题引发的思考/","link":"","permalink":"https://chenyongyang.github.io/2018/10/28/由一道JS题引发的思考/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233// 例子1for (var i = 0; i &lt; 10; ++i) &#123; setTimeout(function () &#123; console.log(i) // 打印出10个10 &#125;, 0);&#125;for (var i = 0; i &lt; 10; ++i) &#123; (function(i)&#123; setTimeout(function () &#123; console.log(i) // 打印出10个10 &#125;, 0); &#125;(i));&#125;// 例子2function func()&#123; for (var i=0; i&lt;5; i++) &#123; setTimeout(function timer() &#123; console.log(new Date(),i); &#125;, 1000*i ); &#125; console.log(\"end\",new Date(),i);&#125;func();/** 打印结果： end Sun Oct 28 2018 13:36:43 GMT+0800 (中国标准时间) 5 Sun Oct 28 2018 13:36:43 GMT+0800 (中国标准时间) 5 Sun Oct 28 2018 13:36:44 GMT+0800 (中国标准时间) 5 Sun Oct 28 2018 13:36:45 GMT+0800 (中国标准时间) 5 Sun Oct 28 2018 13:36:46 GMT+0800 (中国标准时间) 5 Sun Oct 28 2018 13:36:47 GMT+0800 (中国标准时间) 5/ 原因其实都是类似的，setTimeout是采取异步执行机制，它会等主线程先执行完再执行，而等到主线程执行完，也就是循环已经结束了，此时i的值就是让循环终止的那个临界值，setTimeout拿到这个i值执行相应的回调函数，打印结果 那如果想把每个i的值都打印出来呢？闭包就可以解决这个问题 思路是这样的：循环的时候把每次i值存起来，供异步执行回调时使用 本质就是：虽然程序执行完毕，但它的作用域中的变量不会被销毁，保存在内存中，这样回调就使用 继续思考，变量什么时候被销毁？这就涉及到JS垃圾收集机制 最常用的垃圾收集方式是标记清除。也就是当变量进入执行环境后，就将这个变量标记为进入环境；当变量离开环境时，就将变量标记为离开环境。然后将在环境中的变量、被环境中变量所引用的变量的标记去掉，这样还带有标记的变量就是准备删除的，垃圾收集器就会对它们进行内存清除 换言之，当变量不存在与环境中，或者不被环境中变量所引用时，它就会被清除 回到刚才，我们想要的是循环程序执行完毕，每次循环所创建的环境中的变量i保存下来，那就需要让这个i值被处在环境中的程序所引用，处在环境中的程序也就是这个异步回调，那问题就变成如何让这个异步回调引用每次的i值？ 只需要给每次循环创建一个块级作用域就行了。最简单的就是使用ES6的let关键字，它会创建一个块级作用域12345678910111213141516// 例子1for (let i = 0; i &lt; 10; ++i) &#123; setTimeout(function () &#123; console.log(i) // 依次打印出0 1 2 3 ... &#125;, 0);&#125;// 例子2function func()&#123; for (let i=0; i&lt;5; i++) &#123; setTimeout(function timer() &#123; console.log(new Date(),i); // 这里也可以依次打印出i值 &#125;, 1000*i ); &#125; console.log(\"end\",new Date(),i); // 这里取不到i值，因为此时i是块级作用域，外部程序获取不到&#125;func(); 是否还有其他解决方法呢？当然有，它就是闭包。 闭包是什么？理论上任何函数都是闭包，当在函数内返回函数时，内层闭包就能够获取到外层函数作用域上的变量，当外层函数将内层函数返回，并且内层函数还被外部环境所引用时，我们就实现了外部环境获取函数内部作用域变量。外部环境任何时候都能够引用外层函数内部的变量，也就是外层函数的内部变量被外部环境所引用，这时候即使外层函数执行完销毁了，但是存在于它作用域被引用的变量不会被销毁，会一直保存在内存中。 按照这个思路，我们就可以在异步回调的外层在套上一层函数，将每次循环的i值作为参数传递进去，使得i值作为包围函数作用域的变量，这样异步回调执行时，就可以到包围函数的作用域上获取到i值了，这里涉及到作用域链的知识，接下来会单独写一篇来讲作用域链。 现在的情况就是：异步回调引用了外层函数的i值，因此当外层函数随着循环结束而完毕时，内部的i值仍然可以被异步回调所访问。所以我们的程序就变成下面这样：1234567891011121314151617181920// 例子1for (var i = 0; i &lt; 10; ++i) &#123; (function(i)&#123; setTimeout(function () &#123; console.log(i) // 依次打印出0 1 2 3 ... &#125;, 0); &#125;(i));&#125;// 例子2function func()&#123; for (var i=0; i&lt;5; i++) &#123; (function(i)&#123; setTimeout(function timer() &#123; console.log(new Date(),i); // 这里也可以依次打印出0 1 2 ... &#125;, 1000*i ); &#125;(i)); &#125; console.log(\"end\",new Date(),i); // 这里自然就是循环完毕i的临界值，5&#125;func(); 当然我们还可以将包裹定时器的函数单独抽离出来，然后在循环时调用，这里一方面利用了闭包，另一方面也利用了函数的参数是按值传递而不是按引用传递这个原理，代码如下：123456789101112131415161718192021222324252627282930// 例子1let log = function(i)&#123; setTimeout(()=&gt;&#123; console.log(i) &#125;, 1000)&#125;for (var i = 0; i &lt; 10; ++i) &#123; log(i);&#125;// 例子2let log2 = function(i)&#123; setTimeout(function timer() &#123; console.log(new Date(),i); &#125;, 1000*i );&#125;function func()&#123; for (var i=0; i&lt;5; i++) &#123; log2(i); &#125; console.log(\"end\",new Date(),i);&#125;func();/* end Mon Oct 29 2018 10:39:56 GMT+0800 (中国标准时间) 5 Mon Oct 29 2018 10:39:56 GMT+0800 (中国标准时间) 0 Mon Oct 29 2018 10:39:57 GMT+0800 (中国标准时间) 1 Mon Oct 29 2018 10:39:58 GMT+0800 (中国标准时间) 2 Mon Oct 29 2018 10:39:59 GMT+0800 (中国标准时间) 3 Mon Oct 29 2018 10:40:00 GMT+0800 (中国标准时间) 4*/ 还没结束，从代码的组织上看，我们想要实现的效果是循环打印后，在打印最后的end。可是这里由于end这行代码属于同步任务，所以直接进入主线程中执行，那要如何改成我们想要的结果呢？让所有异步任务执行完毕后，再执行同步任务？ 最简单的办法就是让最后这个同步任务也变成异步任务，让它在i*1000后执行，代码如下：1234567891011121314let log2 = function(i)&#123; setTimeout(function timer() &#123; console.log(new Date(),i); &#125;, 1000 * i);&#125;function func()&#123; for (var i=0; i&lt;5; i++) &#123; log2(i); &#125; setTimeout(() =&gt; &#123; console.log(\"end\",new Date(),i); &#125;, i * 1000);&#125;func(); 但是这种实现不够优雅，其实我们可以用ES6的Promise来解决，代码如下： Promise接收两个匿名函数作为参数，这两个函数都接收一个参数，第一个函数接收的参数resolve表示当异步代码执行完，执行resolve()；第二个函数接收参数reject，表示异步代码执行不成功后，执行reject() 问题是promise中，异步代码的参数如何传递呢？直接在promise外层包一个函数，传递进去就行了123456789101112131415161718192021222324252627282930let tasks = [];let log = (i) =&gt; new Promise((resolve) =&gt; &#123; // promise中只处理异步逻辑，其他无关的逻辑都可以放到外面 // 这个resolve回调应该放在哪里？resolve的位置应该在异步代码中 // 下面这种写法是错的，这一点要注意 // setTimeout(() =&gt; &#123; // console.log(new Date(), i); // &#125;, i * 1000); // resolve(); setTimeout(() =&gt; &#123; console.log(new Date(), i); resolve(); &#125;, i * 1000);&#125;, (reject) =&gt; &#123; reject();&#125;);for(var i = 0; i &lt; 5; i++)&#123; tasks.push(log(i));&#125;Promise.all(tasks).then(() =&gt; &#123; console.log('end', new Date(), i);&#125;)/* Mon Oct 29 2018 11:05:44 GMT+0800 (中国标准时间) 0 Mon Oct 29 2018 11:05:45 GMT+0800 (中国标准时间) 1 Mon Oct 29 2018 11:05:46 GMT+0800 (中国标准时间) 2 Mon Oct 29 2018 11:05:47 GMT+0800 (中国标准时间) 3 Mon Oct 29 2018 11:05:48 GMT+0800 (中国标准时间) 4 end Mon Oct 29 2018 11:05:48 GMT+0800 (中国标准时间) 5*/ Promise方案不仅解决了我们代码执行次序的问题，还让我们的异步代码逻辑变成线性的，更加清晰了 最后，让我们来总结一下。这类题目主要考察我们对于JavaScript的异步执行机制、作用域、闭包的理解与运用，是每个前端开发者应该掌握的基础知识。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chenyongyang.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chenyongyang.github.io/tags/JavaScript/"}]},{"title":"HTTP/2初探","slug":"HTTP-2初探","date":"2018-10-28T02:22:40.000Z","updated":"2018-10-28T02:47:42.946Z","comments":true,"path":"2018/10/28/HTTP-2初探/","link":"","permalink":"https://chenyongyang.github.io/2018/10/28/HTTP-2初探/","excerpt":"","text":"HTTP/2新特性1、单一长连接 客户端向服务器请求资源时，不管请求资源的多少，只会建立一条TCP连接。这样就能够减少TCP握手的次数，提高网络效率 HTTP性能优化的关键在于低延迟，主要就是因为建立TCP连接所消耗的时间太长（TCP慢启动），而单一长连接一定程度上缓解了这个问题 2、多路复用 允许同时通过单一HTTP/2连接发起多重的请求-响应消息 这主要是解决了HTTP/1.1限制了客户端在同一时间请求同一域名的次数，超过次数会被阻塞。多路复用使得在同一时间点上，可以存在多个资源的请求，这些不同的请求存放在每个二进制帧中，以此提高并发量 3、头部压缩，通过HPACK算法压缩头部，减少报文体积 4、服务器推送。在客户端还没向服务器请求某资源时，服务器主动推送某资源给客户端，客户端将这个资源缓存起来，以后要用到时就可以直接走缓存了","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/categories/计算机网络/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://chenyongyang.github.io/tags/HTTP/"}]},{"title":"变量提升和函数提升","slug":"变量提升和函数提升","date":"2018-10-27T13:47:47.000Z","updated":"2018-10-27T13:56:26.500Z","comments":true,"path":"2018/10/27/变量提升和函数提升/","link":"","permalink":"https://chenyongyang.github.io/2018/10/27/变量提升和函数提升/","excerpt":"","text":"写程序时，无论是变量还是函数，我们都是先声明后使用，其实也应该是这样来写。 但有时候我们将两者的顺序颠倒了，先使用了变量或先调用了函数，再来声明变量或函数，发现竟然也没报错。 其实这也是因为JavaScript在执行代码之前，已经将变量声明和函数声明都放到内存中了，到了执行阶段程序就可以从内存中读取变量和函数的定义了。 123num = 6;num + 7;var num; // num为13 12345func(\"hello\");function func(str) &#123; console.log(str); // 输出hello&#125; 需要注意的一点是：JavaScript只提升声明，不提升初始化。123var x = 1; console.log(x, y); // 这里y是undefined，因为下面的y不仅仅是声明，是声明并初始化var y = 2;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chenyongyang.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chenyongyang.github.io/tags/JavaScript/"}]},{"title":"Cookie与Session","slug":"Cookie与Session","date":"2018-10-27T12:29:08.000Z","updated":"2018-10-27T13:02:23.933Z","comments":true,"path":"2018/10/27/Cookie与Session/","link":"","permalink":"https://chenyongyang.github.io/2018/10/27/Cookie与Session/","excerpt":"","text":"Cookie和Session都被用于会话跟踪，它们都是为了解决HTTP无状态这一个特性，不同点在于Cookie是在客户端保存状态；而Session是在服务器端保存状态 如果Cookies不设置过期时间，则默认为会话Cookie，这种Cookie存储在内存中，随浏览器关闭而清除；如果设置了过期时间，则Cookies就存储在客户端硬盘中 Session保存在服务器端。通常浏览器第一次访问某页面，发送给服务器的请求中自然就没有携带SESSIONID，那么当服务器就会生成一个SESSIONID，并将其放在响应头中，以cookie的形式返回给客户端，客户端拿到这个ID保存起来，下一次访问时就可以将这个ID发送给服务器端，服务器就可以根据这个ID到保存session的地方寻找对应的数据，将数据返回给客户端 Cookie是实现Session的一种方式，这个SESSIONID就存储在cookie中 如果用户禁用了cookie，服务器端如何跟踪用户呢？利用URL重写，浏览器将SESSIONID作为get请求的参数发送给服务器端，这样服务器照样可以找到session的数据 区别 cookie保存在客户端，session保存在服务器端 session存储量比cookie大 用户可以看到cookie，但是看不到session session依赖SESSIONID，SESSIONID存储在cookie中，从这个角度看，cookie是session的一种实现形式","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://chenyongyang.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://chenyongyang.github.io/tags/HTTP/"}]},{"title":"作用域链与变量解析","slug":"作用域链与变量解析","date":"2018-10-27T11:01:10.000Z","updated":"2018-10-27T11:02:54.611Z","comments":true,"path":"2018/10/27/作用域链与变量解析/","link":"","permalink":"https://chenyongyang.github.io/2018/10/27/作用域链与变量解析/","excerpt":"","text":"概念作用域链是一个对象列表或者链表，这组对象定义了这段代码作用域内的变量 如何产生当代码在一个环境中执行，就会创建这个变量对象的作用域链 变量解析过程变量解析时，首先从作用域链的前端开始，作用域链的前端就是当前执行代码所在环境的变量对象，如果找不到就往后回溯，到上一级执行环境的变量对象中找，如果在链的末端还找不到，则抛出一个引用错误异常","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://chenyongyang.github.io/categories/JavaScript/"}],"tags":[{"name":"作用域链","slug":"作用域链","permalink":"https://chenyongyang.github.io/tags/作用域链/"}]},{"title":"探究vue双向绑定原理","slug":"探究vue双向绑定原理","date":"2018-10-27T06:46:02.000Z","updated":"2018-10-27T07:27:13.993Z","comments":true,"path":"2018/10/27/探究vue双向绑定原理/","link":"","permalink":"https://chenyongyang.github.io/2018/10/27/探究vue双向绑定原理/","excerpt":"","text":"双向绑定就是数据和视图的双向绑定，数据变化更新视图，视图变化更新数据 视图变化更新数据，我们可以通过监听页面上的DOM事件，从而去修改数据 数据变化更新视图，首先进行数据劫持，使得我们能够感知到数据的变化；感知到数据的变化后，通知它的订阅者，订阅者执行更新函数，进而更新视图 订阅者是如何形成的呢？它是通过Compile解析器来实现的，解析器扫描每个节点，将相关指令初始化为一个订阅者Watcher，当然解析器在这个过程中还进行了其他操作，例如更换模板数据、绑定函数等 Observer观察者劫持data对象所有数据，监听数据变动；Compile解析器对每个节点进行解析，提取模板中的各种指令，获取数据对象，将数据更换到模板中，对视图进行初始化渲染，同时将更新视图的函数传递给订阅者；因为一个数据可能不止被用了一次，也就是它可能有多个订阅者，因此我们需要一个数据结构来存储订阅者，它就是Dep，Dep中存储着数据依赖项也就是订阅者，这个过程是在劫持数据对象时get方法中进行的；一旦数据有变动，就进入了set方法，观察者就通知Dep，Dep就通知所有的订阅者，订阅者接收到数据变动后，调用更新函数去更新视图，这就是数据变化更新视图的背后的原理。","categories":[{"name":"vue.js","slug":"vue-js","permalink":"https://chenyongyang.github.io/categories/vue-js/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://chenyongyang.github.io/tags/vue-js/"}]},{"title":"HTTP权威指南学习笔记——HTTPS","slug":"HTTP权威指南学习笔记——HTTPS","date":"2018-10-27T06:10:17.000Z","updated":"2018-10-28T03:16:18.146Z","comments":true,"path":"2018/10/27/HTTP权威指南学习笔记——HTTPS/","link":"","permalink":"https://chenyongyang.github.io/2018/10/27/HTTP权威指南学习笔记——HTTPS/","excerpt":"","text":"HTTPS概述HTTPS的主要原理是，它在将HTTP报文发送给TCP之前，先发给一个安全层，对报文进行加密处理。现在HTTP的安全层是通过SSL和TLS来实现的，一般都统称为SSL。 HTTPS为什么会出现就是因为HTTP存在着以下这些问题：1、被监听，因为HTTP传输的数据是明文，如果中途被劫持了，类似于密码之类的信息就不安全；对此HTTPS对数据进行加密处理 2、被伪装，客户端请求到的数据并一定来源于合法的地址；对此HTTPS采用了数字证书 3、被篡改，HTTP在传输过程中，数据可以随时被改动；对此HTTPS对数据进行摘要，可以感知数据变动 正是出于这些不安全因素，HTTPS应运而生 HTTPS方案一般通过URL来告知Web服务器执行HTTP安全协议版本，也就是URL方案的前缀为http或https 如果URL走的是HTTPS，客户端会开启443默认端口来连接服务器，进行握手过程，同服务器交换SSL安全参数，附上加密的HTTP命令 安全传输建立流程客户端发送一个HTTPS方案的请求之后，客户端会通过443端口与服务器建立连接，TCP连接建立以后，客户端和服务器会初始化SSL层，沟通加密参数，并交换密钥，握手完成后，SSL初始化完成，客户端发送请求报文给安全层。 如何保障安全对称加密、非对称加密、数字证书 加密的HTTPS事务流程 建立到服务器443端口的TCP连接 双方进行SSL安全参数握手 在SSL发送HTTP请求，在TCP发送已经加密的请求 在SSL发送HTTP响应，在TCP发送已经加密的响应 SSL关闭通知 TCP关闭连接 SSL安全参数握手流程 客户端向服务器发送可供选择的密码，并请求证书 服务器发送选中密码和证书 客户端发送保密信息，双方生成密钥 双方互相告知，开始加密过程 站点证书的有效性校验 日期检测 签名颁发者可信度检测 签名检测 站点身份检测 SSL握手简化版流程客户端发送HTTPS请求给服务器端 服务器端选择合适的加密协议后，返回数字证书及公钥 客户端验证数字证书是否合格，如果不合格则提示证书有问题；如果合格；则随机生成对称密钥，使用数字证书上的公钥对其进行加密，发送给服务器端 服务器端使用私钥对证书进行解密，得到客户端的对称密钥，对要返回的内容用对称私钥加密，发送给客户端 客户端通过对称私钥解密，得到数据，握手结束","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/tags/计算机网络/"}]},{"title":"前端性能优化01","slug":"前端性能优化01","date":"2018-10-27T05:48:03.000Z","updated":"2018-10-27T07:27:03.495Z","comments":true,"path":"2018/10/27/前端性能优化01/","link":"","permalink":"https://chenyongyang.github.io/2018/10/27/前端性能优化01/","excerpt":"","text":"前端性能优化可以从很多方面入手，其中网络请求层面是一个重点内容，而这方面一般有两个思路，1、减少网络请求；2、减小网络请求的体积 减少网络请求体积的一般做法有：合并请求资源，制作雪碧图，压缩请求等 js执行层面之所以耗费资源主要是源于内存泄漏，所以我们经常说要及时清空没有被使用的引用 页面渲染层面，一般强调减少DOM操作，这也是虚拟DOM产生的背景","categories":[{"name":"性能优化","slug":"性能优化","permalink":"https://chenyongyang.github.io/categories/性能优化/"}],"tags":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://chenyongyang.github.io/tags/前端性能优化/"}]},{"title":"GET和POST的区别","slug":"GET和POST的区别","date":"2018-10-27T02:31:47.000Z","updated":"2018-10-27T07:26:17.978Z","comments":true,"path":"2018/10/27/GET和POST的区别/","link":"","permalink":"https://chenyongyang.github.io/2018/10/27/GET和POST的区别/","excerpt":"","text":"要讲清楚这两个请求方法的区别，其实可以从RTC（一个互联网规范）对HTTP协议描述的特性出发 HTTP协议对请求方法规定了这几个特性：安全性、幂等性、可缓存性 首先是安全性。如果一个方法的语义是只读，那它就是安全的，也就是意味着它不会对服务器的资源作任何的改动；它是无害的。这些都是属于规范层面，但在实际操纵中的实现不一定是安全的，例如用GET方法修改用户信息 其次是幂等性。概念是同个方法执行多次和执行一次效果是一样的。GET方法是幂等的，POST方法不幂等。原因是可以从为什么要引入幂等性思考？主要是为了处理同一个请求重复发送的问题。例如用户填写了表单，表单数据用POST提交到服务器，此时用户不小心使得浏览器后退或者刷新了页面，浏览器就会提示用户数据会丢失，保证POST过去的都不是重复的 最后是可缓存性。GET方法可以缓存，POST方法不可缓存，这也是处于语义上的需要 还要其他一些区别：GET有长度限制，这和GET是通过URL参数传递信息有关；POST长度不限； 总结：GET方法是获取指定资源，它是安全的、幂等的、可以缓存的；POST方法根据报文主体的payload对指定资源作处理，它是不安全、不幂等 参考链接：MDN上关于HTTP的阐述","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/categories/计算机网络/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://chenyongyang.github.io/tags/HTTP/"}]},{"title":"Vue.js响应式原理","slug":"Vue-js响应式原理","date":"2018-10-26T12:17:02.000Z","updated":"2018-10-27T07:26:02.611Z","comments":true,"path":"2018/10/26/Vue-js响应式原理/","link":"","permalink":"https://chenyongyang.github.io/2018/10/26/Vue-js响应式原理/","excerpt":"","text":"主要由三部分组成Observer Compiler Watcher Observer监听数据变化，使得当数据变化时，我们有能力去执行一些操作 Compiler解析模板，将数据结合模板渲染到页面上 Watcher将两者结合起来，当挂载组件或初始化计算属性时，都会去实例化Watcher，将target传递给Observer，执行数据的getter方法，getter方法中取到target并收集到Dep中，这样就完成了依赖收集；当数据发生变化时，会调用dep.notify方法，通知所有的监听者Watcher，Watcher再调用参数中的回调函数update，更新视图","categories":[{"name":"vue.js","slug":"vue-js","permalink":"https://chenyongyang.github.io/categories/vue-js/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://chenyongyang.github.io/tags/vue-js/"}]},{"title":"Cookie、localStorage、sessionStorage三者的区别","slug":"Cookie、localStorage、sessionStorage三者的区别","date":"2018-10-25T13:20:04.000Z","updated":"2018-10-27T12:27:52.816Z","comments":true,"path":"2018/10/25/Cookie、localStorage、sessionStorage三者的区别/","link":"","permalink":"https://chenyongyang.github.io/2018/10/25/Cookie、localStorage、sessionStorage三者的区别/","excerpt":"","text":"共同点都是客户端存储方案 不同点： Cookie在浏览器和服务器之间传输，附加于HTTP报文中；localStorage、sessionStorage只是活动于浏览器端，不需要和服务器通信 Cookie有path字段，可以规范Cookie的存储路径；localStorage、sessionStorage没有 存储大小方面，Cookie只有4KB；，这是由于它是存在于HTTP报文中，数据量自然不能过大；localStorage、sessionStorage能够存储5MB以上 数据的生命周期方面，Cookie如果是存在于内存中，则在关闭浏览器后便被释放，如果存在于硬盘中，有个过期时间或可手动清除；localStorage如果不手动清除，将会一直存在；sessionStorage在当前浏览器关闭之前有效 作用域方面，Cookie、localStorage只要是同源窗口就能生效（即使是不同浏览器）sessionStorage在不同的浏览器是不同的（即使是同个网站） localStorage、sessionStorage API提供了可监听的事件，可以在数据变动是执行相应动作 应用场景方面：Cookie现在一般用于用户登录信息存储；localStorage、sessionStorage一般用于购物车、存储较大的数据量；表单信息；网站访客统计等；localStorage可做一些数据持久化工作，减少数据库的访问量","categories":[{"name":"前端存储","slug":"前端存储","permalink":"https://chenyongyang.github.io/categories/前端存储/"}],"tags":[{"name":"前端存储","slug":"前端存储","permalink":"https://chenyongyang.github.io/tags/前端存储/"}]},{"title":"一起来学Cookie","slug":"一起来学Cookie","date":"2018-10-25T12:40:39.000Z","updated":"2018-10-27T12:28:11.247Z","comments":true,"path":"2018/10/25/一起来学Cookie/","link":"","permalink":"https://chenyongyang.github.io/2018/10/25/一起来学Cookie/","excerpt":"","text":"是什么 Cookie，也叫作小型文本文件，本质上是存储在客户端的数据，网站能够通过这些数据来辨别用户身份 按照数据存储在客户端不同的位置，可以将Cookie分为内存Cookie、硬盘Cookie 内存Cookie和浏览器挂钩，当关闭了浏览器，其占用的内存也就被释放，内存Cookie自然就被清除；也被称为非持久Cookie 硬盘Cookie，顾名思义就是存储在硬盘中的数据，一般都有个过期时间，用户也可以手动清除；也被称为持久Cookie 应用场景 购物车，当用户选中一个商品到购物车，服务器端返回浏览器页面的同时，也会将选中的商品的信息放入Cookie一起发送过去，当用户再选中商品时，浏览器在发送请求上会带上之前的Cookie，服务器接收到后，就能够将新的商品添加到上一次的商品后一起返回响应，这实际上解决了HTTP无状态所带来的客户操作状态无法保存的限制。 网站登录。第一次登录时如果勾选了自动登录，那么服务器端接收到用户的表单数据，进行一系列验证，返回响应时会携带一个加密的Cookie，这段Cookie将存储在用户硬盘中，当第二次登录时，浏览器就可以发送这段Cookie给服务器，服务器验证通过就可以直接登录了。 不足 Cookie在服务器端和客户端之间的传输，总是附加在HTTP报文中，增加了流量 在HTTP中，Cookie是明文的，不安全；可以考虑HTTPS 存储大小只有4KB，不适合复杂数据存储","categories":[{"name":"前端存储","slug":"前端存储","permalink":"https://chenyongyang.github.io/categories/前端存储/"}],"tags":[{"name":"前端存储","slug":"前端存储","permalink":"https://chenyongyang.github.io/tags/前端存储/"}]},{"title":"前端缓存","slug":"前端缓存","date":"2018-10-21T09:14:21.000Z","updated":"2018-10-27T07:29:16.651Z","comments":true,"path":"2018/10/21/前端缓存/","link":"","permalink":"https://chenyongyang.github.io/2018/10/21/前端缓存/","excerpt":"什么是前端缓存？ 浏览器将对于已经请求过的资源缓存起来，等到下一次请求同样资源时，浏览器直接将缓存副本返回响应，不必向浏览器发送请求 前端缓存的好处 缩短网络请求的距离，减少延迟，加快网页打开速度，性能优化 资源重复利用，减少带宽，降低服务器压力 如何实现前端缓存？","text":"什么是前端缓存？ 浏览器将对于已经请求过的资源缓存起来，等到下一次请求同样资源时，浏览器直接将缓存副本返回响应，不必向浏览器发送请求 前端缓存的好处 缩短网络请求的距离，减少延迟，加快网页打开速度，性能优化 资源重复利用，减少带宽，降低服务器压力 如何实现前端缓存？ 首先来了解与缓存有关的HTTP报文字段 通用首部字段 Pragma 定义在Meta标签，通常指为no-cache，禁用缓存 1&lt;meta http-equiv=\"Pragma\" content=\"no-cache\"&gt; 浏览器设置作用不大，服务器端设置为主 仅IE能识别 与禁用缓存相对的是启用缓存，Expires出现了 Cache-Control 解决服务器和浏览器时间标准不一致 定义缓存过期时间，与Pragma Expires相比，优先级最高 如果资源缓存过期，但资源还是一样，在资源较大的情况下，是不应该又去服务器请求一遍的 我们需要让服务器知道前端缓存的资源是否跟自己一致，如果一致就让浏览器直接用缓存，这时候Last-Modified出现了 请求首部字段 If-Match 浏览器通过PUT方法时，通过这个字段传递ETag If-None-Match 浏览器告诉服务器如果ETag没匹配上，返回新资源，否则返回304 ETag就存储在这个字段中 If-Modified-Since 浏览器通过这个字段告诉服务器如果最后修改时间一致，则返回304 Last-Modified就存储在这个字段中 If-Unmodified-Since 浏览器通过这个字段告诉服务器如果最后修改时间不一致，则返回412 响应首部字段 ETag 服务器返回资源的同时，将ETag一并返回，浏览器接收到后为资源打上这个标记，下一次请求时，将这个值发给服务器，服务器和之前的作对比，如果一致，返回304；否则返回新资源 通过对资源进行某个算法，生成一个类似md5的唯一标识符，而不仅仅靠修改时间 如果和Last-Modified同时使用，需要两者都返回304，才会走缓存，否则返回新资源 实体首部字段 Expires 服务器返回的资源缓存过期时间（GMT 格林尼治时间），时间点是服务器的时间 在浏览器，IE下可以这样设置，这种做法也仅限IE 1&lt;meta http-equiv=\"expires\" content=\"mon, 18 apr 2016 14:30:00 GMT\"&gt; 得在服务器端报头返回该字段，缓存过期时间才能正确生效 同时设置，Pragma优先级更高 但如果服务器和浏览器的时间标准不一致，这个设置也就失效了，因此Cache-Control出现了 Last-Modified 服务器端资源的最后修改时间 服务器向浏览器返回资源的同时，会携带一个Last-Modified，它的值为格林尼治时间；浏览器接收到响应后，会给资源标记上这个值，等到下一次向服务器请求时，将这个值一并发过去，服务器就会对比浏览器发过来的值和之前发给浏览器的值，如果两个最后修改的时间一致，则返回304，让浏览器直接读取缓存资源 不足：当服务器资源被修改，但实际内容没变，这个时候还是会将资源返回，这时候ETag出现了 强缓存不会发送请求到服务器，协商缓存会发送请求到服务器，通过请求首部字段验证 强缓存：Pragma / Expires / Cache-Control 协商缓存：Last-Modified/If-Modified-Since、ETag/If-None-Match If-Modified-Since/Last-ModifiedIf-Modified-Since存在于请求头中，当它被发送到服务器时，服务器会将它和Last-Modified的值作对比，如果两者日期一致，则告知浏览器可以使用本地缓存 If-None-Match/EtagIf-None-Match存储一个字符串，当它被发送到服务器时，服务器会将它和Etag的值作对比，如果匹配上了，则告知浏览器可以使用本地缓存 流程是这样的：浏览器第一次请求页面，服务器在返回结果的同时，也将Last-Modified和Etag值传递过去；浏览器接收到响应，将这两个值都缓存起来；等到下一次请求同个页面，这两个值会将这两个值分别放入If-Modified-Since/If-None-Match并发送到服务器，服务器拿这两个值和之前的作对比，如果其中一个命中，就返回304和空响应体，这就是协商缓存的过程 具体应用 使用Expires来兼容旧浏览器 使用Cache-Control来精准控制缓存 使用ETag和Last-Modified来进一步复用 一般缓存时间为60s 对于静态资源（如图片）则会久一点 浏览器可以在图片的URL后设置max-age 浏览器可以对静态资源以版本形式发布，加上hash值，以确保能及时从服务器获取最新资源","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenyongyang.github.io/tags/计算机网络/"}]},{"title":"动手实现Vue.js响应式","slug":"动手实现Vue-js响应式","date":"2018-10-21T05:43:14.000Z","updated":"2018-10-27T07:27:36.155Z","comments":true,"path":"2018/10/21/动手实现Vue-js响应式/","link":"","permalink":"https://chenyongyang.github.io/2018/10/21/动手实现Vue-js响应式/","excerpt":"想要实现这样的功能：1234567let price = 5let quantity = 2let total = price * quantityconsole.log(total) // 10price = 10 // 修改dataconsole.log(total) // 如果是响应式，就应该是20 现在就是来实现这样的响应式功能 既然要实现改变单价或质量，总价格就会更新，本质上就是当数据改变时，再次执行计价 因此我们应该把这个计价封装成一个函数，以便之后调用123target = () =&gt; &#123; total = price * quantity&#125;","text":"想要实现这样的功能：1234567let price = 5let quantity = 2let total = price * quantityconsole.log(total) // 10price = 10 // 修改dataconsole.log(total) // 如果是响应式，就应该是20 现在就是来实现这样的响应式功能 既然要实现改变单价或质量，总价格就会更新，本质上就是当数据改变时，再次执行计价 因此我们应该把这个计价封装成一个函数，以便之后调用123target = () =&gt; &#123; total = price * quantity&#125; 可能有多个对数据的处理函数，因此我们定义一个数组来存储12storge = []storge.push(target) 以后我们想要调用计较函数，就可以这样1storge.forEach(run =&gt; run()) 完整代码如下1234567891011121314151617181920212223let price = 5let quantity = 2let total = 0let target = nulllet storge = [] // 存储targetfunction recode()&#123; // 将target记录起来 storge.push(target)&#125;function replay()&#123; storge.forEach(run =&gt; run())&#125;target = () =&gt; &#123; total = price * quantity&#125;recode()target()price = 10console.log(total) // 10replay()console.log(total) // 20 我们现在有了一个target，同时将target存储在storge列表中，通过replay方法通知target。这一切都可以封装成一个类，这是依赖类就出现了。12345678910111213141516171819202122232425262728class Dep&#123; constructor()&#123; this.subscribers = []; // 代替storge &#125; depend()&#123; // 代替recode if(target &amp;&amp; !this.subscribers.includes(target))&#123; this.subscribers.push(target) &#125; &#125; notify()&#123; // 代替replay this.subscribers.forEach(sub =&gt; sub()) // run target or observer &#125;&#125;let dep = new Dep()let price = 5let quantity = 2let total = 0let target = () =&gt; &#123; total = price * quantity&#125;dep.depend() // 添加依赖（这个依赖指的是target）target()console.log(total) // 10price = 10console.log(total) // 10dep.notify()console.log(total) // 20 现在还有一点不足：还需要去定义和调用target；我们完全可以把target的定义和调用都封装起来 我们要封装的就是创建监听更新的匿名函数的行为；这时候可以引进Watcher观察者函数123456function watcher(func)&#123; target = func; dep.depend(); target(); target = null&#125; 这样我们就把创建监听更新的匿名函数、依赖的收集都封装到一起。 将代码整合一下1234567891011121314151617181920212223242526272829303132class Dep&#123; constructor(func)&#123; this.subscribers = []; // 代替storge this.target = null; this.watcher(func); &#125; depend()&#123; // 代替recode if(this.target &amp;&amp; !this.subscribers.includes(this.target))&#123; this.subscribers.push(this.target) &#125; &#125; notify()&#123; // 代替replay this.subscribers.forEach(sub =&gt; sub()) // run target or observer &#125; watcher(func)&#123; this.target = func this.depend() this.target() this.target = null &#125;&#125;let price = 5;let quantity = 2let total = 0let dep = new Dep(()=&gt;&#123;total = price * quantity&#125;);price = 10 // data数据修改console.log(total) // 10dep.notify() // dep通知target更新console.log(total) // 20 到此为止，当我们修改数据一修改，只要通知存储在依赖类实例的target，即可实现依赖数据的修改 但我们还需要手动执行dep.notify，我们希望数据一修改就自动执行dep.notify，而且应该是每个数据都有这个能力 我们希望当访问数据对象属性时，将target所指向的更新函数添加到subscribers中；当修改数据对象属性时，通知其依赖数据 我们需要一些方式来挂钩数据属性，使得当访问它时，能够将target推送到subscribers数组中；当它被修改时，运行存储在subscribers数组中的函数 这时候就需要Object.defineProperty() 最终代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142let data = &#123; price: 5, quantity: 2&#125;let target = nullclass Dep&#123; constructor()&#123; this.subscribers = [] &#125; depend()&#123; if(target &amp;&amp; !this.subscribers.includes(target))&#123; this.subscribers.push(target) &#125; &#125; notify()&#123; this.subscribers.forEach(sub=&gt;sub()) &#125;&#125;Object.keys(data).forEach(key =&gt; &#123; let value = data[key] let dep = new Dep() Object.defineProperty(data, key, &#123; get()&#123; dep.depend() return value; &#125;, set(newValue)&#123; value = newValue dep.notify() &#125; &#125;)&#125;)function watcher(func)&#123; target = func target() target = null&#125;watcher(() =&gt; &#123; data.total = data.price * data.quantity&#125;) 至此，我们实现了price quantity的响应式，一旦数据更改，依赖的数据也随之更改","categories":[{"name":"vue.js","slug":"vue-js","permalink":"https://chenyongyang.github.io/categories/vue-js/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://chenyongyang.github.io/tags/vue-js/"}]},{"title":"小知识点总结","slug":"小知识点总结","date":"2018-09-28T12:52:21.000Z","updated":"2018-10-28T12:53:26.606Z","comments":true,"path":"2018/09/28/小知识点总结/","link":"","permalink":"https://chenyongyang.github.io/2018/09/28/小知识点总结/","excerpt":"","text":"DOCTYPE 告知浏览器按照哪个版本的Html进行编写命令，什么类型的文档定义来解析文档 div不换行 display: inline-block float flex position: absolute","categories":[],"tags":[]},{"title":"学习Vue.js源码的前置知识","slug":"学习Vue-js源码的前置知识","date":"2018-07-21T04:00:00.000Z","updated":"2018-10-27T07:27:44.437Z","comments":true,"path":"2018/07/21/学习Vue-js源码的前置知识/","link":"","permalink":"https://chenyongyang.github.io/2018/07/21/学习Vue-js源码的前置知识/","excerpt":"","text":"前置知识 Flow JavaScript静态类型检测，类似于typescript object.defineProperty proxy get set","categories":[{"name":"vue.js","slug":"vue-js","permalink":"https://chenyongyang.github.io/categories/vue-js/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://chenyongyang.github.io/tags/vue-js/"}]},{"title":"Hexo基本操作","slug":"Hexo基本操作","date":"2017-10-30T00:00:00.000Z","updated":"2018-10-27T07:27:26.934Z","comments":true,"path":"2017/10/30/Hexo基本操作/","link":"","permalink":"https://chenyongyang.github.io/2017/10/30/Hexo基本操作/","excerpt":"","text":"写文章 hexo new 文章标题 预览效果 hexo s 开启hexo server 在localhost调试 发布到github page hexo clean 清除历史数据 hexo d -g 先生成再发布","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://chenyongyang.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://chenyongyang.github.io/tags/Hexo/"}]}]}